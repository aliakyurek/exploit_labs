### Info
In this lab, we'll convert hello_world of previous lab to a shellcode. It'll not spawn shell at the moment but it'll meet some requirements of a shellcode.<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS, ASLR enabled<br>
**Keywords**: shellcode, position independent, intel, x86, assembly, assembler

### Implementation
A shellcode must have the following properties:
* They must be small to be able to fit small buffers. This is not achievable with a high level compiler. I mean we can't
create a shellcode in C language.
* It must be position independent and we can't make assumptions about program state.
* It shouldn't contain null characters otherwise the string copy functions that will copy them to target will fail.
#### Info
We can't use the hello_world as shellcode. Looking at the code below, there are two reasons:
```
uzi@pwnpatrol:$ objdump -M intel -d hello_world
hello_world:     file format elf32-i386
Disassembly of section .text:
08048080 <_start>:
 8048080:       b8 04 00 00 00          mov    eax,0x4
 8048085:       bb 01 00 00 00          mov    ebx,0x1
 804808a:       b9 a4 90 04 08          mov    ecx,0x80490a4
 804808f:       ba 08 00 00 00          mov    edx,0x8
 8048094:       cd 80                   int    0x80
 8048096:       b8 01 00 00 00          mov    eax,0x1
 804809b:       bb 00 00 00 00          mov    ebx,0x0
 80480a0:       cd 80                   int    0x80
```
* There are many null bytes in the code.
* It has code with position dependency. $ecx is assigned an absolute address (msg).

#### Overcoming null bytes
The one byte assignments to 32-bit registers create three bytes of padding.
* Since the values we assign to $eax, $ebx, $edx fits to one byte, we can use $al, $bl, $dl in mov instructions.
In other words, `mov reg8,val` instead of `mov reg32,val`
However in this case, only the single byte in the registers will be set.
What if the other bytes contain non-zero value? 
* So if we can be sure that registers are whole zero at the beginning of shellcode, we're done.
* How can we do it? We can't have `mov eax,0`. What we can use is a smaller and a faster alternative -> xor reg,reg.
Notice that the opcodes for `xor` are smaller than `mov reg32,val` in the listing above.
```
31 c0     xor    eax,eax
31 db     xor    ebx,ebx
31 c9     xor    ecx,ecx
31 d2     xor    edx,edx
b0 04     mov    al,0x4
b3 01     mov    bl,0x1
```

#### Overcoming absolute references
A trick to get rid of referencing address of some data, is to push the data to stack and referring to $esp than.
Therefore we'll be pushing "Owned!!\n" string to stack. But we won't be using newline. Because if the shellcode will be injected when the program is waiting user input, newline will trigger end of input and remaining bytes won't be transferred.
Here are the bytes we need to push
```
uzi@pwnpatrol:$ echo -n 'Owned!!' | xxd -g 1
00000000: 4f 77 6e 65 64 21 21 
```
* There are 7 btyes here, without a newline or null byte, we can't push 7 bytes to stack since in 32-bit, we can push 4-byte values or 32-bit registers. Solution is simple. Just add one more ! to the end, making the string "Owned!!!".
So the bytes are `4f 77 6e 65 64 21 21 21`.
* As we need to push 8 bytes to stack, we do it in two increments. First we push the second half of the string, then push the first half since stack grows upwards.
* Also due to the little endianness of X86 CPU, in each push, the byte are in LE order. Finally $esp is asigned to $ecx
```
;Owned!!! =  4f,77,6e,65,64,21,21,21
;push !,!,!,d
push 0x21212164
;push e,n,w,O 
push 0x656e774f
mov ecx, esp
```

#### Final code and compilation
We also remove other symbols, exit system call so on as we don't need them in a shellcode. For compilation, this time we don't generate a elf32 file but a pure binary file composing of just binary code without any symbol any header etc. For this reason we need to tell nasm, we are generating code for 32-bit. The directive `[bits 32]` added for this purpose.
```
[bits 32]
xor eax, eax
xor ebx, ebx
xor ecx, ecx
xor edx, edx
;write(int fd, char *msg, unsigned int len)
mov al, 4
mov bl, 1
;Owned!!! =  4f,77,6e,65,64,21,21,21
;push !,!,!,d
push 0x21212164
;push e,n,w,O 
push 0x656e774f
mov ecx, esp
mov dl, 8
int 0x80
```

#### Test
Without injecting it to a program, we can't test this shellcode. That's the part of next lab.

