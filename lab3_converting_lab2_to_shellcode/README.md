### Info
In this lab, we'll convert hello_world of previous lab to a shellcode.<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS<br>
**Keywords**:shellcode, position independent, intel, x86, assembly, 

### Implementation
A shellcode must have the following properties:
* They must be small to be able to fit small buffers. This is not achievable with a high level compiler. I mean we can't
create a shellcode in C language.
* It must be position independent and we can't make assumptions about program state.
* It shouldn't contain null characters otherwise the string copy functions that will copy them to target will fail.
#### Info
We can't use the hello_world as shellcode. Looking at the code below, there are two reasons:
```
uzi@pwnpatrol:$ objdump -M intel -d hello_world
hello_world:     file format elf32-i386
Disassembly of section .text:
08048080 <_start>:
 8048080:       b8 04 00 00 00          mov    eax,0x4
 8048085:       bb 01 00 00 00          mov    ebx,0x1
 804808a:       b9 a4 90 04 08          mov    ecx,0x80490a4
 804808f:       ba 08 00 00 00          mov    edx,0x8
 8048094:       cd 80                   int    0x80
 8048096:       b8 01 00 00 00          mov    eax,0x1
 804809b:       bb 00 00 00 00          mov    ebx,0x0
 80480a0:       cd 80                   int    0x80
```
* It has code with position dependency. $ecx is assigned an absolute address (msg).
* There are many null bytes in the code.

#### Overcoming the issues
The one byte assignments to 32-bit registers create three bytes of padding.
* Since the values we assign to $eax, $ebx, $edx fits to one byte, we can use $al, $bl, $dl in mov instructions.
In other words, `mov reg8,val` instead of `mov reg32,val`
However in this case, only the single byte in the registers will be set.
What if the other bytes contain non-zero value? 
* So if we can be sure that registers are whole zero at the beginning of shellcode, we're done.
* How can we do it? We can't have `mov eax,0`. What we can use is a smaller and a faster alternative -> xor reg,reg.
Notice that the opcodes for `xor` are smaller than `mov reg32,val` in the listing above.
```
31 c0     xor    eax,eax
31 db     xor    ebx,ebx
31 c9     xor    ecx,ecx
31 d2     xor    edx,edx
b0 04     mov    al,0x4
b3 01     mov    bl,0x1
```
