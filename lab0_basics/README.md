### Info
In this lab, we'll cover the basics about gdb, gcc, linux required for the labs.<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS<br>
**Keywords**: gdb, gcc, shell, linux, peda

### What you may not know about Linux and gdb?
Even if you may have used gdb before to debug your code on Linux, I'm sure that you used a minimum subset of its features. For example, have you ever noticed that
gdb disables the address randomization or put a breakpoint at the *really* entry of a function?

Let's start a journey and go deeper as much as possible in X86 that is 32bit code. In this journey you'll see various utilities and their usage.<br>
#### Functions and Addresses
Here is our code in `basic.c` dumping address of main function.
```
int main(int argc, char **argv)
{
    int var=0xdeadcafe;
    printf("%p",main);
}
```
Compile&link it with `gcc -m32 basic.c -o basic`<br>
Now run it several times.
```
uzi@pwnpatrol:$ ./basic
0x5659151d
uzi@pwnpatrol:$ ./basic
0x565bf51d
uzi@pwnpatrol:$ ./basic
0x5664e51d
```
As you've noticed, the address pattern has some constant 0x......51d in the end, and 0x56..... in the beginning. You may have different results in your environment.
Checking with `nm`, 0x51d is the offset of main function in the binary. `grep` needed to focus on the line we're interested in.
```
uzi@pwnpatrol:$ nm basic | grep main
         U __libc_start_main@@GLIBC_2.0
0000051d T main
```
We can crosscheck with `objdump` and see the instructions. `-A 12` passed to grep, shows 12 more lines after the occurence 
```
uzi@pwnpatrol:$ objdump -M intel -D basic | grep "<main>" -A 12
0000051d <main>:
 51d:   8d 4c 24 04             lea    ecx,[esp+0x4]
 521:   83 e4 f0                and    esp,0xfffffff0
 524:   ff 71 fc                push   DWORD PTR [ecx-0x4]
 527:   55                      push   ebp
 528:   89 e5                   mov    ebp,esp
 52a:   53                      push   ebx
 52b:   51                      push   ecx
 52c:   83 ec 10                sub    esp,0x10
 52f:   e8 36 00 00 00          call   56a <__x86.get_pc_thunk.ax>
 534:   05 a4 1a 00 00          add    eax,0x1aa4
 539:   c7 45 f4 fe ca ad de    mov    DWORD PTR [ebp-0xc],0xdeadcafe
 540:   83 ec 08                sub    esp,0x8
 ```
By the way, 0x51d is really the physical offset in the file. A `hexdump` helps us to see the bytes in a given offset.
```
uzi@pwnpatrol:$ hexdump -C -n 16 -s 0x51d basic
0000051d  8d 4c 24 04 83 e4 f0 ff  71 fc 55 89 e5 53 51 83  |.L$.....q.U..SQ.|
```
So it seems that, ELF (this is the most common file format for executables and libraries on Linux) loader loads the binary to a random virtual address by default.
It turns out that this is a security technique called `Address space layout randomization (ASLR)`. With ASLR, The base, heap, and stack addresses are positioned randomly when the binary is to run.
What is the outcome? Suppose somehow you injected a code to a vulnerable application, and you should know its address to run that piece of code on victim. If this was a constant address, you could exploit it on every victim.
But the address will be different always. This is how ASLR hardens exploitation.<br>
Now run the binary with gdb two times.
```
uzi@pwnpatrol:$ gdb -q ./basic
(gdb) r
Starting program: /home/uzi/exploit_labs/lab0_basics/basic
0x5655551d
[Inferior 1 (process 20236) exited normally]
(gdb) quit
uzi@pwnpatrol:$ gdb -q ./basic
(gdb) r
Starting program: /home/uzi/exploit_labs/lab0_basics/basic
0x5655551d
[Inferior 1 (process 20243) exited normally]
(gdb)
```
When run with gdb, randomization does not occur. This makes sense due to purpose of debugging. When debugging your program as a software developer, you'd like things to be reproducible.
Now try this:
```
(gdb) set disable-randomization off
(gdb) r
Starting program: /home/uzi/exploit_labs/lab0_basics/basic
0x565c051d
[Inferior 1 (process 20251) exited normally]
(gdb) r
Starting program: /home/uzi/exploit_labs/lab0_basics/basic
0x5664951d
[Inferior 1 (process 20252) exited normally]
(gdb)
```
We see that gdb disables randomization by default and it's possible to turn it off.
Address randomization can be disabled globally on Linux (but won't survive a restart) as the following with root.
```
echo 0 > /proc/sys/kernel/randomize_va_space
```
This is a setting we'll use on our exploit development machines.
#### pie,nopie
When learning exploitation, it's easier when the addresses are fixed in the binary. Because even if you disable ASLR, there'll be a virtual base address decided by OS. Can't we dictate the address? Actually this is possible. First let's check the ELF header.
```
uzi@pwnpatrol:$ readelf -h basic
ELF Header:
  Version:                           0x1
  Entry point address:               0x3e0
```
The entry point is 0x3e0. This is the first instruction that will be executed when the binary is loaded to memory. Actually this points to the code so called libc_start_main that will call `main` of the binary.
Now recompile the binary with the new gcc flags `gcc -m32 -no-pie -fno-pie basic.c -o basic` and recheck ELF header. Here it is:
```
uzi@pwnpatrol:$ readelf -h basic
ELF Header:
  Version:                           0x1
  Entry point address:               0x8048310
```
Also check with the assembler. The leftmost column shows the fixed memory address that'll be used when the binary is being executed.
```
uzi@pwnpatrol:$ objdump -M intel -D basic | grep "<main>" -A 20
08048426 <main>:
 ...
 8048437:       c7 45 f4 fe ca ad de    mov    DWORD PTR [ebp-0xc],0xdeadcafe
 804843e:       83 ec 08                sub    esp,0x8
 8048441:       68 26 84 04 08          push   0x8048426
 8048446:       68 e0 84 04 08          push   0x80484e0
 804844b:       e8 90 fe ff ff          call   80482e0 <printf@plt>
 ...
```
We achieved this result with two flags controlling position independent executable. Depending on the distribution, it's enabled by default in GCC. Following flags disable it.
* fno-pie: This is the compiler flag to gcc. (this affects the generated assembly code)
* no-pie: This is the linker flag to gcc. (this affects how the linking is done, arranging ELF so that loader will use the addresses as they are etc...)
#### Deep in stack: Environment and arguments
In the main function, we access the arguments passed to the binary using first two parmeters namely argc (argument count), argv (pointer to pointer array). There's also a third parameter we can use pointing to the array of pointers for environment variables.<br>
A nice python based add-on called "peda" is an excellent tool when working with gdb for exploitation. We'll use it to see how parameters to main are located in the memory.<br>
After installing peda and activating it in gdb, gdb propmp will look like this:
```
uzi@pwnpatrol:$ gdb -q basic
Reading symbols from basic...(no debugging symbols found)...done.
gdb-peda$
```
Peda extends gdb in multiple ways
* New commands
* Colorizing the gdb output
* A nice layouting of code, stack and registers.

With our binary loaded in gdb, put a breakpoint to the really entry point of main using `b *main`. The `*` used in gdb to assign a breakpoint to an arbitrary address. If a function name appended it puts the breakpoint exactly to the first instruction in function.<br><br>
This is different than doing `b main`. This is the common usage while debugging as a software developer. In this usage, gdb puts the breakpoint after function prologue preparing stack and registers. This part of code doesn't contain our business logic in C source code.<br><br>
We have our breakpoint set, now run the binary passing a single argument to it with `gdb-peda$ r hello`. Here is the result:
![](image.png)

In this state (breakpoint hit at first instruction of main), stack should look like the following: Return address to the caller and parameters passed (in reverse order of declaration, so called standard calling convention).

``` 
lower address
+-------------------------------+
| ret addr to libc_...          |
+-------------------------------+
| argc                          |
+-------------------------------+
| argv pointer (to the p. array |
+-------------------------------+
| env pointer (to the p. array  |
+-------------------------------+
higher address
```

The stack output in peda screenshot confirms this. Currently the stack pointer points to 0xffffd58c. There's the return address here, and there's argc next so on.
The arguments passed to the binary (remember that filename/path is the first argument by default) is at 0xffffd624. This is far away from current stack location. We can use a telescope to its content.
```
gdb-peda$ telescope 0xffffd624
0000| 0xffffd624 --> 0xffffd752 ("/home/uzi/exploit_labs/lab0_basics/basic")
0004| 0xffffd628 --> 0xffffd77b ("hello")
0008| 0xffffd62c --> 0x0
0012| 0xffffd630 --> 0xffffd781 ("LS_COLORS=rs=0:di=01;34:ln=01;36:mh
```
We can clearly see the arguments. Following the arguments, there are environment variables. So we can conclude that, the  binary loader puts arguments, environment variables to deep in stack.

Here is the memory layout of the process when it's ready to run:
```
...lower address
+----------------------- -+
|                         |
|     text (code)         |
|                         |
+----------------------- -+
|                         |
|     uninitialized data  |
|                         |
+----------------------- -+
|                         |
|     initialized data    |
|                         |
+----------------------- -+ 
|                         | || growth
|     Heap                | \/
|                         |
+----------------------- -+
|                         |
|     Stack               |
|                         |
|   Arguments             | 
|   Env. variables        | /\
+----------------------- -+ || growth
...higher address
```
#### Stack alignment

