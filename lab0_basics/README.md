### 0.Info
In this lab, we'll cover the basics about gdb, gcc, linux required for the labs.<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS<br>
**Keywords**: gdb, gcc, shell, linux, peda

### What you may not know about Linux and gdb?
Even if you may have used gdb before to debug your code on Linux, I'm sure that you used a minimum subset of its features. For example, have you ever noticed that
gdb disables the address randomization or put a breakpoint at the *really* entry of a function?

Let's start a journey and go deeper as much as possible in X86 that is 32bit code. In this journey you'll see various utilities and their usage.<br>
#### 1. Functions and Addresses
Here is our code in `basic.c` dumping address of main function.
```
int main(int argc, char **argv)
{
    int var=0xdeadcafe;
    printf("%p",main);
}
```
Compile&link it with `gcc -m32 basic.c -o basic`<br>
On 64bit Ubuntu you may see errors in compilation due to non-existing 32bit headers and libraries. In this case, please install them as the following:
`sudo apt-get install gcc-multilib`

Now run it several times.
```
uzi@pwnpatrol:$ ./basic
0x5659151d
uzi@pwnpatrol:$ ./basic
0x565bf51d
uzi@pwnpatrol:$ ./basic
0x5664e51d
```
As you've noticed, the address pattern has some constant 0x......51d in the end, and 0x56..... in the beginning. You may have different results in your environment.
Checking with `nm`, 0x51d is the offset of main function in the binary. `grep` needed to focus on the line we're interested in.
```
uzi@pwnpatrol:$ nm basic | grep main
         U __libc_start_main@@GLIBC_2.0
0000051d T main
```
We can crosscheck with `objdump` and see the instructions. `-A 12` passed to grep, shows 12 more lines after the occurence 
```
uzi@pwnpatrol:$ objdump -M intel -D basic | grep "<main>" -A 12
0000051d <main>:
 51d:   8d 4c 24 04             lea    ecx,[esp+0x4]
 521:   83 e4 f0                and    esp,0xfffffff0
 524:   ff 71 fc                push   DWORD PTR [ecx-0x4]
 527:   55                      push   ebp
 528:   89 e5                   mov    ebp,esp
 52a:   53                      push   ebx
 52b:   51                      push   ecx
 52c:   83 ec 10                sub    esp,0x10
 52f:   e8 36 00 00 00          call   56a <__x86.get_pc_thunk.ax>
 534:   05 a4 1a 00 00          add    eax,0x1aa4
 539:   c7 45 f4 fe ca ad de    mov    DWORD PTR [ebp-0xc],0xdeadcafe
 540:   83 ec 08                sub    esp,0x8
 ```
By the way, 0x51d is really the physical offset in the file. A `hexdump` helps us to see the bytes in a given offset.
```
uzi@pwnpatrol:$ hexdump -C -n 16 -s 0x51d basic
0000051d  8d 4c 24 04 83 e4 f0 ff  71 fc 55 89 e5 53 51 83  |.L$.....q.U..SQ.|
```
So it seems that, ELF (this is the most common file format for executables and libraries on Linux) loader loads the binary to a random virtual address by default.
#### 2. ASLR
It turns out that, what's revealed above is a security technique called `Address space layout randomization (ASLR)`. With ASLR, The base, heap, and stack addresses are positioned randomly when the binary is to run.
What is the outcome? Suppose somehow you injected a code to a vulnerable application, and you should know its address to run that piece of code on victim. If this was a constant address, you could exploit it on every victim.
But the address will be different always. This is how ASLR hardens exploitation.<br>
Now run the binary with gdb two times.
```
uzi@pwnpatrol:$ gdb -q ./basic
(gdb) r
Starting program: /home/uzi/exploit_labs/lab0_basics/basic
0x5655551d
[Inferior 1 (process 20236) exited normally]
(gdb) quit
uzi@pwnpatrol:$ gdb -q ./basic
(gdb) r
Starting program: /home/uzi/exploit_labs/lab0_basics/basic
0x5655551d
[Inferior 1 (process 20243) exited normally]
(gdb)
```
When run with gdb, randomization does not occur. This makes sense due to purpose of debugging. When debugging your program as a software developer, you'd like things to be reproducible.
Now try this:
```
(gdb) set disable-randomization off
(gdb) r
Starting program: /home/uzi/exploit_labs/lab0_basics/basic
0x565c051d
[Inferior 1 (process 20251) exited normally]
(gdb) r
Starting program: /home/uzi/exploit_labs/lab0_basics/basic
0x5664951d
[Inferior 1 (process 20252) exited normally]
(gdb)
```
We see that gdb disables randomization by default and it's possible to turn it off.
Address randomization can be disabled globally on Linux (but won't survive a restart) as the following with:
```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```
This is a setting we'll use on our exploit development machines.
#### 3. Fixed code and data addresses
When learning exploitation, it's easier when the addresses are fixed in the binary. Because even if you disable ASLR, there'll be a virtual base address decided by OS. Can't we dictate the address? Actually this is possible. First let's check the ELF header.
```
uzi@pwnpatrol:$ readelf -h basic
ELF Header:
  Version:                           0x1
  Entry point address:               0x3e0
```
The entry point is 0x3e0. This is the first instruction that will be executed when the binary is loaded to memory. Actually this points to the code so called libc_start_main that will call `main` of the binary.
Now recompile the binary with the new gcc flags `gcc -m32 -no-pie -fno-pie basic.c -o basic` and recheck ELF header. Here it is:
```
uzi@pwnpatrol:$ readelf -h basic
ELF Header:
  Version:                           0x1
  Entry point address:               0x8048310
```
Also check with the assembler. The leftmost column shows the fixed memory address that'll be used when the binary is being executed. But that's not the actual proof as we'll see later. The real proof is the hardcoded addresses pushed with push instruction where you can verify by seeing the bytes "68 26 84 04 08" and "68 e0 84 04 08" in the middle column. The first of them is address of main and the second one is address of "%p\n" from the readonly data section (.rodata). You can verify this with `objdump -s basic | grep rodata -A 5` as well.

```
uzi@pwnpatrol:$ objdump -M intel -D basic | grep "<main>" -A 20
08048426 <main>:
 ...
 8048437:       c7 45 f4 fe ca ad de    mov    DWORD PTR [ebp-0xc],0xdeadcafe
 804843e:       83 ec 08                sub    esp,0x8
 8048441:       68 26 84 04 08          push   0x8048426
 8048446:       68 e0 84 04 08          push   0x80484e0
 804844b:       e8 90 fe ff ff          call   80482e0 <printf@plt>
 ...
```
We achieved this result with two flags controlling position independent executable. Depending on the distribution, it's enabled by default in GCC. Following flags disable it.
* fno-pie: This is the compiler flag to gcc. (this affects the generated assembly code. That's addresses in code uses hard coded addresses or not)
* no-pie: This is the linker flag to gcc. (this affects how the linking is done, arranging ELF entry point, informing loader accordingly etc.)
#### 4. pie, nopie
We can check first how linker flag effects the generated elf.By the way, in my gcc build, fpie is enabled by default. That's why I add fpie suffix to the filenames to be precise.
So we have two files:
* pie_fpie: Built with pie and fpie(implicitly)
* nopie_fpie: Build with nopie and fpie(implicitly)

As you can see below, file created with pie enabled shows "shared object". So we can say that a pie executable is an ELF shared object, as opposed to an ELF "executable". An ELF executable has a fixed entry point in the ELF headers assigned by the linker. Therefore ASLR randomization of code and data area is not possible with these type of executable. But the dynamic areas like stack and dynamic libraries can be still randomized for such a binary.
```
uzi@pwnpatrol:$ gcc -m32 -no-pie basic.c -o nopie_fpie
uzi@pwnpatrol:$ gcc -m32 basic.c -o pie_fpie
uzi@pwnpatrol:$ file pie_fpie
pie: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=7f2586442a1a6627c7319d655dfa5b6a794d50af, not stripped
uzi@pwnpatrol:$ file nopie_fpie
nopie: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=0005ac92374e1c7656da0b95087a9ad9685e748c, not stripped
```
A comparison of headers proves that the entry point address is relative in pie executable. If you check all of the pie file you'll see all address references are relative. On the other hand nopie executable has fixed address 0x8048****
```
uzi@pwnpatrol:$ diff <(readelf -h nopie_fpie) <(readelf -h pie_fpie)
8c8
<   Type:                              EXEC (Executable file)
---
>   Type:                              DYN (Shared object file)
11c11
<   Entry point address:               0x8048310
---
>   Entry point address:               0x3e0
13c13
<   Start of section headers:          5976 (bytes into file)
---
>   Start of section headers:          6060 (bytes into file)
19,20c19,20
<   Number of section headers:         30
<   Section header string table index: 29
---
>   Number of section headers:         29
>   Section header string table index: 28
```
#### 5. mystery of objdump
As I've mentioned early, the leftmost address column of objdump shows fixed memory address but that's not the proof of fixed memory address are used in code.
objdump tries to show you what the contents of memory would look like when your executable is loaded into memory. It outputs that address information by combining entry point and physical offset information. So by looking at the addresses below in leftmost column and call instruction address parameter 80482e0, don't assume that compiler generated position dependent code. Because we didn't use -fnopie (which generates position dependent code) in the executable and we don't see hardcoded addresses in push instructions that push address of "%p\n" and main.
```
uzi@pwnpatrol:$ objdump -M intel -D nopie_fpie | grep "<main>" -A 20
08048426 <main>:
  ...
 8048449:       83 ec 08                sub    esp,0x8
 804844c:       8d 90 26 e4 ff ff       lea    edx,[eax-0x1bda]
 8048452:       52                      push   edx
 8048453:       8d 90 00 e5 ff ff       lea    edx,[eax-0x1b00]
 8048459:       52                      push   edx
 804845a:       89 c3                   mov    ebx,eax
 804845c:       e8 7f fe ff ff          call   80482e0 <printf@plt>
```
So where does the 80482e0 parameter to call come from? If you look at the instruction bytes this value is not there but there's e8 7f fe ff ff. If you check "call" insturction in X86 references, you'll see that it has several opcodes alternatives. The one used here is e8 and it uses relative address. The operand is fffffe7f that's -385. objdump simply does the calculation and outputs there the resulting value.
#### 6. fpie, fnopie
Now let's see the how fpie and fno-pie affect the generated code. To compare it, we create another nopie executable with fno-pie compiler flag.
So we have two files:
* nopie_fpie: Built with nopie and fpie(implicitly)
* nopie_fnopie: Build with nopie and fnopie
```
uzi@pwnpatrol:$ objdump -M intel -D nopie_fpie | grep "<main>" -A 20
08048426 <main>:
 8048426:       8d 4c 24 04             lea    ecx,[esp+0x4]
 804842a:       83 e4 f0                and    esp,0xfffffff0
 804842d:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048430:       55                      push   ebp
 8048431:       89 e5                   mov    ebp,esp
 8048433:       53                      push   ebx
 8048434:       51                      push   ecx
 8048435:       83 ec 10                sub    esp,0x10
 8048438:       e8 36 00 00 00          call   8048473 <__x86.get_pc_thunk.ax>
 804843d:       05 c3 1b 00 00          add    eax,0x1bc3
 8048442:       c7 45 f4 fe ca ad de    mov    DWORD PTR [ebp-0xc],0xdeadcafe
 8048449:       83 ec 08                sub    esp,0x8
 804844c:       8d 90 26 e4 ff ff       lea    edx,[eax-0x1bda]
 8048452:       52                      push   edx
 8048453:       8d 90 00 e5 ff ff       lea    edx,[eax-0x1b00]
 8048459:       52                      push   edx
 804845a:       89 c3                   mov    ebx,eax
 804845c:       e8 7f fe ff ff          call   80482e0 <printf@plt>
 8048461:       83 c4 10                add    esp,0x10
 8048464:       b8 00 00 00 00          mov    eax,0x0
uzi@pwnpatrol:$ objdump -M intel -D nopie_fnopie | grep "<main>" -A 20
08048426 <main>:
 8048426:       8d 4c 24 04             lea    ecx,[esp+0x4]
 804842a:       83 e4 f0                and    esp,0xfffffff0
 804842d:       ff 71 fc                push   DWORD PTR [ecx-0x4]
 8048430:       55                      push   ebp
 8048431:       89 e5                   mov    ebp,esp
 8048433:       51                      push   ecx
 8048434:       83 ec 14                sub    esp,0x14
 8048437:       c7 45 f4 fe ca ad de    mov    DWORD PTR [ebp-0xc],0xdeadcafe
 804843e:       83 ec 08                sub    esp,0x8
 8048441:       68 26 84 04 08          push   0x8048426
 8048446:       68 e0 84 04 08          push   0x80484e0
 804844b:       e8 90 fe ff ff          call   80482e0 <printf@plt>
 8048450:       83 c4 10                add    esp,0x10
 8048453:       b8 00 00 00 00          mov    eax,0x0
 8048458:       8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]
 804845b:       c9                      leave
 804845c:       8d 61 fc                lea    esp,[ecx-0x4]
 804845f:       c3                      ret
```
It's clear that in nopie_fnopie executable, the address references are hardcoded like (push   0x8048426, address of main) and (push   0x80484e0, address of "%p\n") from readonly data area (you can verify with objdump -M intel -D nopie_fnopie).<br/>
So how nopie_fpie executable finds address of main and "%p\n"? The weird code `call   8048473 <__x86.get_pc_thunk.ax>` is available for position independent code scheme. Basically during runtime, it loads the address of next instruction to the register `eax` (.ax: loads to aax, .bx loads to ebx etc...). Then using every function/data (which have a fixed offset from the code) can be accessed as an offset from this register.
#### Deep in stack: Environment and arguments
In the main function, we access the arguments passed to the binary using first two parmeters namely argc (argument count), argv (pointer to pointer array). There's also a third parameter we can use pointing to the array of pointers for environment variables.<br>
A nice python based gdb add-on called "peda" is an excellent tool when working with gdb for exploitation. We'll use it to see how parameters to main are located in the memory.<br>
After installing peda and activating it in gdb, gdb propmp will look like this:
```
uzi@pwnpatrol:$ gdb -q basic
Reading symbols from basic...(no debugging symbols found)...done.
gdb-peda$
```
Peda extends gdb in multiple ways
* New commands
* Colorizing the gdb output
* A nice layouting of code, stack and registers.

With our binary loaded in gdb, put a breakpoint to the really entry point of main using `b *main`. The `*` used in gdb to assign a breakpoint to an arbitrary address. If a function name appended it puts the breakpoint exactly to the first instruction in function.<br><br>
This is different than doing `b main`. This is the common usage while debugging as a software developer. In this usage, gdb puts the breakpoint after function prologue preparing stack and registers. This part of code doesn't contain our business logic in C source code.<br><br>
We have our breakpoint set, now run the binary passing a single argument to it with `gdb-peda$ r hello`. Here is the result:
![](image.png)

In this state (breakpoint hit at first instruction of main), stack should look like the following: Return address to the caller and parameters passed (in reverse order of declaration, so called standard calling convention).

``` 
lower address
+-------------------------------+
| ret addr to libc_...          |
+-------------------------------+
| argc                          |
+-------------------------------+
| argv pointer (to the p. array |
+-------------------------------+
| env pointer (to the p. array  |
+-------------------------------+
higher address
```

The stack output in peda screenshot confirms this. Currently the stack pointer points to 0xffffd58c. There's the return address here, and there's argc next so on.
The arguments passed to the binary (remember that filename/path is the first argument by default) is at 0xffffd624. This is far away from current stack location. We can use a telescope to its content.
```
gdb-peda$ telescope 0xffffd624
0000| 0xffffd624 --> 0xffffd752 ("/home/uzi/exploit_labs/lab0_basics/basic")
0004| 0xffffd628 --> 0xffffd77b ("hello")
0008| 0xffffd62c --> 0x0
0012| 0xffffd630 --> 0xffffd781 ("LS_COLORS=rs=0:di=01;34:ln=01;36:mh
```
We can clearly see the arguments. Following the arguments, there are environment variables. So we can conclude that, the  binary loader puts arguments, environment variables to deep in stack.

Here is the memory layout of the process when it's ready to run:
```
...lower address
+----------------------- -+
|                         |
|     text (code)         |
|                         |
+----------------------- -+
|                         |
|     uninitialized data  |
|                         |
+----------------------- -+
|                         |
|     initialized data    |
|                         |
+----------------------- -+ 
|                         | || growth
|     Heap                | \/
|                         |
+----------------------- -+
|                         |
|     Stack               |
|                         |
|   Arguments             | 
|   Env. variables        | /\
+----------------------- -+ || growth
...higher address
```
The ELF header has all the info for the loader to know where to load and map the file. We can see it as the following:
```
uzi@pwnpatrol:$ readelf -l basic

Elf file type is EXEC (Executable file)
Entry point 0x8048310
There are 9 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R   0x4
  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1
  LOAD           0x000000 0x08048000 0x08048000 0x00614 0x00614 R E 0x1000
  LOAD           0x000f0c 0x08049f0c 0x08049f0c 0x00110 0x00114 RW  0x1000
  DYNAMIC        0x000f14 0x08049f14 0x08049f14 0x000e8 0x000e8 RW  0x4
  ...
 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame
   03     .init_array .fini_array .dynamic .got .got.plt .data .bss
...
```
For example, it specifies that file content at offset 0x000000 should be mapped to 0x08048000 with readable and executable permission. This is the segment containing our code section plus some other sections as shown in section to segment mapping above. 
#### Stack alignment
When we check the disassembly of main, we see that there are 3 instructions before the traditional function prolog (push ebp; move ebp,esp). 
```
=> 0x8048426 <main>:    lea    ecx,[esp+0x4]
   0x804842a <main+4>:  and    esp,0xfffffff0
   0x804842d <main+7>:  push   DWORD PTR [ecx-0x4]
   0x8048430 <main+10>: push   ebp
   0x8048431 <main+11>: mov    ebp,esp
```
When the instruction pointer is on this line above, the value of $esp is return addr to libc_ as shown below
```
[------------------------------------stack-------------------------------------]
0000| 0xffffd58c --> 0xf7e01e91 (<__libc_start_main+241>:       add    esp,0x10)
0004| 0xffffd590 --> 0x1
0008| 0xffffd594 --> 0xffffd624 --> 0xffffd756 ("/home/uzi/exploit_labs/lab0_basics/basic")
0012| 0xffffd598 --> 0xffffd62c --> 0xffffd77f ("LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33
```
After 3 instructions executed
```
0000| 0xffffd57c --> 0xf7e01e91 (<__libc_start_main+241>:       add    esp,0x10)
0004| 0xffffd580 --> 0xf7fc1000 --> 0x1d7d6c
0008| 0xffffd584 --> 0xf7fc1000 --> 0x1d7d6c
0012| 0xffffd588 --> 0x0
0016| 0xffffd58c --> 0xf7e01e91 (<__libc_start_main+241>:       add    esp,0x10)
```
The reason is to keep the stack aligned to a 16-byte boundary that begins with its return address across function calls. $ecx points to argc and it also helps us to find original return address ($ecx-4). This default value of 16 bytes is from the i386 ABI speficiation. This is way GCC by default align stack to 16 bytes. 
However by using "mpreferred-stack-boundary", it can be modified.

Once the main stack frame is aligned, this allows the rest of the code to run without further adjustment. But of course care msut be taken to always allocate stack in multiples of 16 bytes before a call.
