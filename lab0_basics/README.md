### Info
In this lab, we'll cover the basics about gdb, gcc, linux required for the labs.<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS<br>
**Keywords**: gdb, gcc, shell, linux

### What you may not know about Linux and gdb?
Even if you may have used gdb before to debug your code on Linux, I'm sure that you used a minimum subset of its features. For example, have you ever noticed that
gdb disables the address randomization or put a breakpoint at the *really* entry of a function?

Let's start a journey and go deeper as much as possible. In this journey you'll see various utilities and their usage.<br>
#### Functions and Addresses
Here is our code in `basic.c` dumping address of main function.
```
int main(int argc, char **argv)
{
    int var=0xdeadcafe;
    printf("%p",main);
}
```
Compile&link it with `gcc -m32 basic.c -o basic`<br>
Now run it several times.
```
uzi@pwnpatrol:$ ./basic
0x5659151d
uzi@pwnpatrol:$ ./basic
0x565bf51d
uzi@pwnpatrol:$ ./basic
0x5664e51d
```
As you've noticed, the address pattern has some constant 0x......51d in the end, and 0x56..... in the beginning.
Checking with `nm`, 0x51d is the offset of main function in the binary. `grep` needed to focus on the line we're interested in.
```
uzi@pwnpatrol:$ nm basic | grep main
         U __libc_start_main@@GLIBC_2.0
0000051d T main
```
We can crosscheck with `objdump` and see the instructions. `-A 12` passed to grep, shows 12 more lines after the occurence 
```
uzi@pwnpatrol:$ objdump -M intel -D basic | grep "<main>" -A 12
0000051d <main>:
 51d:   8d 4c 24 04             lea    ecx,[esp+0x4]
 521:   83 e4 f0                and    esp,0xfffffff0
 524:   ff 71 fc                push   DWORD PTR [ecx-0x4]
 527:   55                      push   ebp
 528:   89 e5                   mov    ebp,esp
 52a:   53                      push   ebx
 52b:   51                      push   ecx
 52c:   83 ec 10                sub    esp,0x10
 52f:   e8 36 00 00 00          call   56a <__x86.get_pc_thunk.ax>
 534:   05 a4 1a 00 00          add    eax,0x1aa4
 539:   c7 45 f4 fe ca ad de    mov    DWORD PTR [ebp-0xc],0xdeadcafe
 540:   83 ec 08                sub    esp,0x8
 ```
By the way, 0x51d is really the physical offset. A `hexdump` helps us to see the bytes in a given offset.
```
uzi@pwnpatrol:$ hexdump -C -n 16 -s 0x51d basic
0000051d  8d 4c 24 04 83 e4 f0 ff  71 fc 55 89 e5 53 51 83  |.L$.....q.U..SQ.|
```
So it seems that, ELF (this is the most common file format for executables and libraries on Linux) file loader loads the binary to a random virtual address by default.
It turns out that this is a security technique called `Address space layout randomization (ASLR)`. With ASLR, The base, heap, and stack addresses are positioned randomly when the binary is to run.
What is the outcome? Suppose somehow you injected a code to a vulnerable application, and you should know its address to run that piece of code on victim. If this was a constant address, you could exploit it on every victim.
But the address will be different always. This is how ASLR hardens exploitation.<br>
Now run the binary with gdb two times.
```
uzi@pwnpatrol:$ gdb -q ./basic
(gdb) r
Starting program: /home/uzi/exploit_labs/lab0_basics/basic
0x5655551d
[Inferior 1 (process 20236) exited normally]
(gdb) quit
uzi@pwnpatrol:$ gdb -q ./basic
(gdb) r
Starting program: /home/uzi/exploit_labs/lab0_basics/basic
0x5655551d
[Inferior 1 (process 20243) exited normally]
(gdb)
```
When run with gdb, randomization does not occur. This makes sense due to purpose of debugging. When debugging your program as a software developer, you'd like things to be reproducible.
Now try this:
```
(gdb) set disable-randomization off
(gdb) r
Starting program: /home/uzi/exploit_labs/lab0_basics/basic
0x565c051d
[Inferior 1 (process 20251) exited normally]
(gdb) r
Starting program: /home/uzi/exploit_labs/lab0_basics/basic
0x5664951d
[Inferior 1 (process 20252) exited normally]
(gdb)
```
We see that gdb disables randomization by default and it's possible to turn it off.
Address randomization can be disabled globally on Linux (but won't survive a restart) as the following with root.
```
echo 0 > /proc/sys/kernel/randomize_va_space
```
This is a setting we'll use on our exploit development machines.
#### pie,nopie
...
#### Deep in stack: Environment and arguments
...


