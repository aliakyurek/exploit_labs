### Info
In this lab, we'll be creating executable from assembly code. This is a must before understanding shellcodes better.<br><br>
**Environment**: Ubuntu 18.04.3 LTS<br>
**Keywords**: assembly, assembler, linker, symbol table, relocation, shellcode, nasm, ld, elf

### Implementation
#### Intro
Shellcodes are the small programs that we inject to the exploit payloads and try to execute on target for various tasks like
opening a forward or reverse shell, connecting to a remote location and downloading further commands to execute etc.<br/> 
A shellcode must have the following properties:
* They must be small to be able to fit small buffers. This is not achievable with a high level compiler. I mean we can't
create a shellcode in C language.
* It must be position independent and we can't make assumptions about program state.
* It shouldn't contain null characters otherwise the string copy fcuntions that will copy them to target will fail.

Shellcodes consist of system calls which are the services which request from the kernel. They are one of the bridges between application and kernel.
We'll write a 32-bit assembly program utilizing system calls. This program will just print a message to console, in other words, it'll write to standard output. Later we'll convert it to a shellcode because it doesn't have the properties above.

#### Syscalling
We need to know the following to be able make a system call.
* System call number: We need to get the number of `write`. We can get it by grepping headers. Since we'll be dealing with 32-bit, `4` is what we're looking for. We'll assign this number to $eax.
```
uzi@pwnpatrol:$ grep write /usr/include/asm/unistd*.h
/usr/include/asm/unistd_32.h:#define __NR_write 4
...
/usr/include/asm/unistd_64.h:#define __NR_write 1
```
* What are the argument of `write`? We can get it by looking at level 2 of corresponding man page. We'll use $ebx, $ecx, $edx to pass arguments. Notice that in 32-bit, when calling a C library function, arguments passed to stack. When making a system call, arguments passed in register.
  * fd: will be 1 since this is the number representing stdout in linux.
  * buf: will be address of string. We'll see it later.
  * count: will be length of string.
```
uzi@pwnpatrol:$ man 2 write
...
NAME
       write - write to a file descriptor
SYNOPSIS
       #include <unistd.h>
       ssize_t write(int fd, const void *buf, size_t count);
```
* Finally, we trigger the system call using `int 0x80` instruction.
#### Code
Here is the code
```
section .data
msg db 'Owned!!',0xa

section .text
global _start

_start:
;write(int fd, char *msg, unsigned int len)
mov eax, 4
mov ebx, 1
mov ecx, msg
mov edx, 8
int 0x80

;exit(int ret)
mov eax,1
mov ebx,0
int 0x80
```
It has two sections named as `.data` and `.text`. The text section will be readonly and data section will be read-write when OS loads the program. We need to export `_start` for linker to be able to find entry point, otherwise it would complain. We do it by using `global`. Otherwise it'd be a local symbol like `msg` Also an exit call added, so that program succesfully exits. 1 is the code of exit, and 0 is the return code

#### Compilation
We'll use `nasm` assembler and as target object format, we'll select elf. An assembler is basically simple compiler that converts assembly code to machine code. Here is the assembling process and symbol table of resulting object.
```
uzi@pwnpatrol:$ nasm -f elf hello_world.asm 
uzi@pwnpatrol:$ objdump -t hello_world.o
hello_world.o:     file format elf32-i386
SYMBOL TABLE:
00000000 l    df *ABS*  00000000 hello_world.asm
00000000 l    d  .data  00000000 .data
00000000 l    d  .text  00000000 .text
00000000 l       .data  00000000 msg
00000000 g       .text  00000000 _start
```
We can see the code as well (you can omit "-M intel", and see the code in AT&T syntax which disturbs me) using objdump again but this time with -t parameter.
```
uzi@pwnpatrol:$ objdump -M intel -d hello_world.o
hello_world.o:     file format elf32-i386
Disassembly of section .text:
00000000 <_start>:
   0:   b8 04 00 00 00          mov    eax,0x4
   5:   bb 01 00 00 00          mov    ebx,0x1
   a:   b9 00 00 00 00          mov    ecx,0x0
   f:   ba 08 00 00 00          mov    edx,0x8
  14:   cd 80                   int    0x80
  16:   b8 01 00 00 00          mov    eax,0x1
  1b:   bb 00 00 00 00          mov    ebx,0x0
  20:   cd 80                   int    0x80
```
Curious reader may notice that $ecx is assigned 0x0. That's expected since at this phase, assembler does not know the address of msg.
In the linking phase, linking updates this field based on the relocation table as shown below. This table basically says that, during linking,
update the word at offset 0x0000000b with the value of `.data` once it's decided.
```
uzi@pwnpatrol:$ objdump -r hello_world.o
hello_world.o:     file format elf32-i386
RELOCATION RECORDS FOR [.text]:
OFFSET   TYPE              VALUE 
0000000b R_386_32          .data
```
#### Linking
We link with ld, and pass `-m elf_i386` since our program is 32-bit. We can see the elf header with readelf.
```
uzi@pwnpatrol:$ ld -m elf_i386 -o hello_world hello_world.o
uzi@pwnpatrol:$ readelf -h hello_world
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048080
  ...
```
In the previous objdump symbol table output, the addresses were all zero, after linking now the linker assigned the addreses.
```
uzi@pwnpatrol:$ objdump -t hello_world
hello_world:     file format elf32-i386
SYMBOL TABLE:
08048080 l    d  .text  00000000 .text
080490a4 l    d  .data  00000000 .data
00000000 l    df *ABS*  00000000 hello_world.asm
080490a4 l       .data  00000000 msg
08048080 g       .text  00000000 _start
080490ac g       .data  00000000 __bss_start
080490ac g       .data  00000000 _edata
080490ac g       .data  00000000 _end
```

#### Execution
If not done yet, chmod the executable `chmod u+x hello_world`
Here we go!
```
uzi@pwnpatrol:$ ./hello_world
Owned!!
```

#### Stripping 
While linking, if we pass `-s` to `ld`, it strips the symbols, resulting a smaller footprint. However during debugging or reverse engineering, you'll have difficulty since you can't find the functions.
```
uzi@pwnpatrol:$ objdump -t hello_world_stripped 
hello_world_stripped:     file format elf32-i386
SYMBOL TABLE:
no symbols
```
