### Info
In this lab, we'll inject and run the shellcode we created in lab3 to the vulnerable simple_login program in lab1 and trigger its execution.<br/><br/>
**Environment**: Ubuntu 18.04.3 LTS<br>
**Keywords**: buffer, overflow, shellcode, exploit, nop, nopsled, payload

### Implementation
There are two prerequisites to make it work
- ASLR must be disabled. ASLR is a security technique that makes it hard to predict target addresses for exploits.Basically, in every run
of an executable, OS generates different address layouts for stack, and shared libraries. You'll see later in lab why we need to disable it.
It's disabled as the following:
`echo 0 | sudo tee /proc/sys/kernel/randomize_va_space`. 
- Stack must be executable as also shown in lab4.
In lab1 where we manipulated return address, the payload was 80 bytes containing 76 bytes of junk data + 4 bytes of the return address we intended. For this lab, we'll prepare a payload which with a very different content.

#### How to layout the payload
We need to remember the stack layout of `authorize` function.
![](../lab1_simple_login_analysis/image.png)

As it can be seen, we have 76 bytes space that we can place shellcode. So, how many bytes our shellcode have? -> 28 as below.
```
uzi@pwnpatrol:$ wc -c ../lab3_converting_lab2_to_shellcode/hello_shellcode
28 ../lab3_converting_lab2_to_shellcode/hello_shellcode
```
Our goal is to create a payload, such that:
* It'll include the shellcode to be executed.
* It must replace the return address of `authorize` function with the address of shellcode. So that when the authorize function is to return, it'll execute our shellcode.

We have some options listed below.(the numbers inside parenthesis indicate number of bytes):
##### Option 1
Put the shellcode to the beginning, fill the remaining bytes with junkdata like 'A's, and reserving last 4 bytes for address of shellcode.
```
 __________________ __________________ __________________
|                  |                  |    shellcode     |
|  shellcode(28)   |  junkdata(48)    |    address(4)    |
|__________________|__________________|__________________|
```
Well, this may work, but...Even with ASLR disabled, the address of password buffer (to be used as shellcode address)  is very volatile. Why? Let me show with examples:
* Use ltrace to see the address of password buffer and do it twice.
```
uzi@pwnpatrol:$ ltrace ./simple_login 
__libc_start_main(0x80485cf, 1, 0xffffd5e4, 0x8048610 <unfinished ...>
printf("Enter Password: ")
gets(0xffffd4e0, 0xc10000, 0, 0xf7ffd000Enter Password: )
...

uzi@pwnpatrol:$ ltrace ./simple_login 
__libc_start_main(0x80485cf, 1, 0xffffd5e4, 0x8048610 <unfinished ...>
printf("Enter Password: ")
gets(0xffffd4e0, 0xc10000, 0, 0xf7ffd000Enter Password: )
```
